<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pure Life</title>
  
  <subtitle>一亩三分路漫漫</subtitle>
  <link href="chunlife.top/atom.xml" rel="self"/>
  
  <link href="chunlife.top/"/>
  <updated>2024-08-18T10:44:56.265Z</updated>
  <id>chunlife.top/</id>
  
  <author>
    <name>xiaoshi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>桌面客户端Golang-Wails快速开发</title>
    <link href="chunlife.top/2024/08/18/%E6%A1%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AFGolang-Wails%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/"/>
    <id>chunlife.top/2024/08/18/%E6%A1%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AFGolang-Wails%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/</id>
    <published>2024-08-18T09:41:47.000Z</published>
    <updated>2024-08-18T10:44:56.265Z</updated>
    
    <content type="html"><![CDATA[<p>之前还在做嵌入式的时候就用Qt做过客户端应用，但是转Go后，一直还没写过客户端，前面也用过Amis这类前端低代码，写过Web界面，算起来也是非常方便的，适合不想理会前端的各类知识。</p><p>但是有些场景，用户就是需要桌面客户端这样的形式的时候，就没办法说用B/S这样的架构交付了。</p><p>Go的GUI库，比较火的有两个，<code>Fyne</code>和<code>Wails</code>。经过一段时间的使用，这里推荐使用<code>Wails</code>。</p><a id="more"></a><p>需要说明的是，当前<code>Wails</code>仅支持桌面端，不像<code>Fyne</code>是同时支持桌面、移动设备的。</p><h3><span id="组件">组件</span></h3><p><code>Wails</code>的<a href="https://wails.io/zh-Hans/" target="_blank" rel="noopener">官网</a>。</p><p>使用<code>Wails</code>，就能利用起前端的各类资源，这里推荐一个前端库<a href="https://www.quasar-cn.cn/introduction-to-quasar" target="_blank" rel="noopener"><code>quasar</code></a>，<code>quasar</code>库比较有那种桌面客户端的风格，不会像写<code>element-plus</code>一样，看起来跟Web页面一样。</p><h3><span id="使用">使用</span></h3><p>因为我们需要的页面不会是那种非常复杂的页面，所以只需要些许JS和CSS基础即可，更何况当前使用时，可以随时借助各类AI工具，所以当前使用难度几乎是被降的很低的。</p><p>我在使用时，只做一些单页面，对前端知识要求基本查<code>quasar</code>的文档，都有解决的方案（前端框架真的很卷）。</p><p>我使用的模板：<a href="https://github.com/sgosiaco/wails-template-quasar-js" target="_blank" rel="noopener">https://github.com/sgosiaco/wails-template-quasar-js</a></p><p>这是使用wails实现的一个应用。</p><p><img src="image-20240818184224418.png" alt="打印页面"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前还在做嵌入式的时候就用Qt做过客户端应用，但是转Go后，一直还没写过客户端，前面也用过Amis这类前端低代码，写过Web界面，算起来也是非常方便的，适合不想理会前端的各类知识。&lt;/p&gt;
&lt;p&gt;但是有些场景，用户就是需要桌面客户端这样的形式的时候，就没办法说用B/S这样的架构交付了。&lt;/p&gt;
&lt;p&gt;Go的GUI库，比较火的有两个，&lt;code&gt;Fyne&lt;/code&gt;和&lt;code&gt;Wails&lt;/code&gt;。经过一段时间的使用，这里推荐使用&lt;code&gt;Wails&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="Go" scheme="chunlife.top/tags/Go/"/>
    
    <category term="Wails" scheme="chunlife.top/tags/Wails/"/>
    
  </entry>
  
  <entry>
    <title>SECS/GEM-Golang解包、封包库</title>
    <link href="chunlife.top/2023/11/15/SECS-GEM-Golang%E8%A7%A3%E5%8C%85%E3%80%81%E5%B0%81%E5%8C%85%E5%BA%93/"/>
    <id>chunlife.top/2023/11/15/SECS-GEM-Golang%E8%A7%A3%E5%8C%85%E3%80%81%E5%B0%81%E5%8C%85%E5%BA%93/</id>
    <published>2023-11-15T02:54:14.000Z</published>
    <updated>2024-08-18T09:37:52.296Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇算是有时间就补一下以前做的事。之前有提过Go有Encode/Decode SML/HSMS消息的库，该库对SECS2基协议解析基础完备的支持，易于使用的话需要对其进行一些细微的修改。</p><p>这个库的学习可以通过各个文件的Test案例进行了解，基本上使用起来不会有太大的问题。</p><a id="more"></a><h2><span id="库简单讲解">库简单讲解</span></h2><p>库中对Go语言Duck Type的运用是很优秀的，而且也是很常用的。</p><p>例如，通过对<a href="https://en.wikipedia.org/wiki/SECS-II" target="_blank" rel="noopener">SECS-II</a>数据节点的抽象；对HSMS消息的抽象。这些在看源码时，都是可以有心学习的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ItemNode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Size returns the array size of the data item.</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Variables returns the variable names in the node, in the insertion order.</span></span><br><span class="line">    Variables() []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    FillVariables(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;) ItemNode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ToBytes returns the byte representation of the data item.</span></span><br><span class="line">    ToBytes() []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HSMSMessage <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Type returns HSMS message type.</span></span><br><span class="line"><span class="comment">// Return will be one of "data message", "select.req", "select.rsp", "deselect.req", "deselect.rsp",</span></span><br><span class="line"><span class="comment">// "linktest.req", "linktest.rsp", "reject.req", "separate.req", "undefined".</span></span><br><span class="line">Type() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToBytes returns byte representation of the HSMS message.</span></span><br><span class="line">ToBytes() []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，经过我对比其他库，这个库的优点是对消息中变量的支持，可以事先插入变量在SML消息中进行占位，在后面对这些变量占位进行填充。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NewIntNode(<span class="number">2</span>, <span class="string">"var1"</span>).FillVariables(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"var1"</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;I2[1] 1&gt;</span></span><br></pre></td></tr></table></figure><hr><p>但是，这里存在一个问题，这个库对数据获取的没有提供一个好的方式，例如我想获取List嵌套下的某一个Int中的第二个元素，这个就没办法了，需要我们自己进行拓展。例如Java中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github.com/kenta-shimizu/secs4java8</span></span><br><span class="line"></span><br><span class="line">Secs2 ss = Secs2.list(</span><br><span class="line">    Secs2.binary((<span class="keyword">byte</span>)<span class="number">1</span>),<span class="comment">/* 0 */</span></span><br><span class="line">    Secs2.ascii(<span class="string">"MESSAGE-1"</span>),<span class="comment">/* 1 */</span></span><br><span class="line">    Secs2.bool(<span class="keyword">true</span>),<span class="comment">/* 2 */</span></span><br><span class="line">    Secs2.list(<span class="comment">/* 3 */</span></span><br><span class="line">        Secs2.list(<span class="comment">/* 3,0 */</span></span><br><span class="line">            Secs2.ascii(<span class="string">"KEY-1"</span>),<span class="comment">/* 3,0,0 */</span></span><br><span class="line">            Secs2.int4(<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>)<span class="comment">/* 3,0,1 */</span></span><br><span class="line">        ),</span><br><span class="line">        Secs2.list(<span class="comment">/* 3,1 */</span></span><br><span class="line">            Secs2.ascii(<span class="string">"KEY-2"</span>),<span class="comment">/* 3,1,0 */</span></span><br><span class="line">            Secs2.int4(<span class="number">200</span>, <span class="number">201</span>, <span class="number">202</span>)<span class="comment">/* 3,1,1 */</span></span><br><span class="line">        ),</span><br><span class="line">        Secs2.list(<span class="comment">/* 3,2 */</span></span><br><span class="line">            Secs2.ascii(<span class="string">"KEY-3"</span>),<span class="comment">/* 3,2,0 */</span></span><br><span class="line">            Secs2.int4(<span class="number">300</span>, <span class="number">301</span>, <span class="number">302</span>)<span class="comment">/* 3,2,1 */</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    Secs2.float4(<span class="number">400.0F</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"# Get value by index"</span>);</span><br><span class="line">System.out.println(<span class="string">"getByte(0, 0):\t"</span> + ss.getByte(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">/* 1 */</span></span><br><span class="line">System.out.println(<span class="string">"getAscii(1):\t"</span> + ss.getAscii(<span class="number">1</span>));<span class="comment">/* "MESSAGE-1" */</span></span><br><span class="line">System.out.println(<span class="string">"getBoolean(2, 0):\t"</span> + ss.getBoolean(<span class="number">2</span>, <span class="number">0</span>));<span class="comment">/* true */</span></span><br><span class="line">System.out.println(<span class="string">"getAscii(3, 0, 0):\t"</span> + ss.getAscii(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">/* "KEY-1" */</span></span><br><span class="line">System.out.println(<span class="string">"getInt(3, 0, 1, 0):\t"</span> + ss.getInt(<span class="number">3</span>, <span class="number">0</span> , <span class="number">1</span>, <span class="number">0</span>));<span class="comment">/* 100 */</span></span><br><span class="line">System.out.println(<span class="string">"getInt(3, 0, 1, 1):\t"</span> + ss.getInt(<span class="number">3</span>, <span class="number">0</span> , <span class="number">1</span>, <span class="number">1</span>));<span class="comment">/* 101 */</span></span><br><span class="line">System.out.println(<span class="string">"getInt(3, 0, 1, 2):\t"</span> + ss.getInt(<span class="number">3</span>, <span class="number">0</span> , <span class="number">1</span>, <span class="number">2</span>));<span class="comment">/* 102 */</span></span><br><span class="line">System.out.println(<span class="string">"getInt(3, 1, 1, 0):\t"</span> + ss.getInt(<span class="number">3</span>, <span class="number">1</span> , <span class="number">1</span>, <span class="number">0</span>));<span class="comment">/* 200 */</span></span><br><span class="line">System.out.println(<span class="string">"getInt(3, 2, 1, 0):\t"</span> + ss.getInt(<span class="number">3</span>, <span class="number">2</span> , <span class="number">1</span>, <span class="number">0</span>));<span class="comment">/* 300 */</span></span><br><span class="line">System.out.println(<span class="string">"getFloat(4, 0):\t"</span> + ss.getFloat(<span class="number">4</span>, <span class="number">0</span>));<span class="comment">/* 400.0F */</span></span><br></pre></td></tr></table></figure><h2><span id="修改">修改</span></h2><p>库中对消息节点的解析已经将数据解析到节点的values中，但是没有获取数据的method。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntNode <span class="keyword">struct</span> &#123;</span><br><span class="line">byteSize  <span class="keyword">int</span>            <span class="comment">// Byte size of the integers; should be either 1, 2, 4, or 8</span></span><br><span class="line">values    []<span class="keyword">int64</span>        <span class="comment">// Array of integers</span></span><br><span class="line">variables <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">// Variable name and its position in the data array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是要将其暴露出去，给到外部进行获取。</p><p><code>ItemNode</code>增加三个方法，Values、Get、Type.</p><p>Values：获取节点上的数据；</p><p>Get：获取节点，主要是List节点；</p><p>Type：标识数据节点；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ItemNode <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get returns list itemNode</span></span><br><span class="line">    Get(indices ...<span class="keyword">int</span>) (ItemNode, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values returns data list</span></span><br><span class="line">    Values() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type returns item type</span></span><br><span class="line">    Type() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List节点<code>Get</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *ListNode)</span> <span class="title">Get</span><span class="params">(indices ...<span class="keyword">int</span>)</span> <span class="params">(ItemNode, error)</span></span> &#123;</span><br><span class="line">itemNode := ItemNode(node)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(indices) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, index := <span class="keyword">range</span> indices &#123;</span><br><span class="line"><span class="keyword">if</span> itemNode.Type() != <span class="string">"list"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not list"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listNode := itemNode.(*ListNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">len</span>(listNode.values) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"index out of bounds error, size : %d"</span>, <span class="built_in">len</span>(listNode.values))</span><br><span class="line">&#125;</span><br><span class="line">itemNode = listNode.values[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> itemNode, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他节点<code>Get</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *IntNode)</span> <span class="title">Get</span><span class="params">(indices ...<span class="keyword">int</span>)</span> <span class="params">(ItemNode, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(indices) == <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> node, <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not list, node is %s, indices is %v"</span>, node, indices)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给<code>DataMessage</code>添加获取节点数据的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GetAscii(indices ...<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">GetByte(indices ...<span class="keyword">int</span>) (<span class="keyword">byte</span>, error)</span><br><span class="line">GetBoolean(indices ...<span class="keyword">int</span>) (<span class="keyword">bool</span>, error)</span><br><span class="line">GetFloat(indices ...<span class="keyword">int</span>) (<span class="keyword">float64</span>, error)</span><br><span class="line">GetInt(indices ...<span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">Get(indices ...<span class="keyword">int</span>) (ItemNode, error)</span><br></pre></td></tr></table></figure><p>这样，即可获取到指定数据节点的信息，效果和Java库是一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">func TestMessageNode_ProducedByFactoryMethod_HSMS11(t *testing.T) &#123;</span><br><span class="line">var tests = []struct &#123;</span><br><span class="line">description       string   // Test case description</span><br><span class="line">inputMessageName  string   // Input to the factory method</span><br><span class="line">inputStreamCode   int      // Input to the factory method</span><br><span class="line">inputFunctionCode int      // Input to the factory method</span><br><span class="line">inputWaitBit      int      // Input to the factory method</span><br><span class="line">inputDirection    string   // Input to the factory method</span><br><span class="line">inputItemNode     ItemNode // Input to the factory method</span><br><span class="line">inputSessionID    int      // Input to the factory method</span><br><span class="line">inputSystemBytes  []byte   // Input to the factory method</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">description:       &quot;S127F255 W H&lt;-&gt;E 消息名称, upper boundary, nested list node&quot;,</span><br><span class="line">inputMessageName:  &quot;消息名称&quot;,</span><br><span class="line">inputStreamCode:   127,</span><br><span class="line">inputFunctionCode: 255,</span><br><span class="line">inputWaitBit:      1,</span><br><span class="line">inputDirection:    &quot;H&lt;-&gt;E&quot;,</span><br><span class="line">inputItemNode: NewListNode(</span><br><span class="line">NewListNode(NewListNode()),</span><br><span class="line">NewListNode(</span><br><span class="line">NewIntNode(1, 33, 55),</span><br><span class="line">NewASCIINode(&quot;test&quot;),</span><br><span class="line">NewBinaryNode(1, 2, 255),</span><br><span class="line">NewBooleanNode(false, true, true),</span><br><span class="line">NewFloatNode(4, -1.1, 0.0, 1.0),</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">inputSessionID:   0xFFFF,</span><br><span class="line">inputSystemBytes: []byte&#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">for i, test := range tests &#123;</span><br><span class="line">t.Logf(&quot;Test #%d: %s&quot;, i, test.description)</span><br><span class="line">msg := NewHSMSDataMessage(</span><br><span class="line">test.inputMessageName,</span><br><span class="line">test.inputStreamCode,</span><br><span class="line">test.inputFunctionCode,</span><br><span class="line">test.inputWaitBit,</span><br><span class="line">test.inputDirection,</span><br><span class="line">test.inputItemNode,</span><br><span class="line">test.inputSessionID,</span><br><span class="line">test.inputSystemBytes,</span><br><span class="line">)</span><br><span class="line">fmt.Println(msg.dataItem)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;-------------------&quot;)</span><br><span class="line">node, err := msg.Get(1, 0)</span><br><span class="line">fmt.Println(node)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">getInt, err := msg.GetInt(1, 0, 1)</span><br><span class="line">fmt.Println(getInt, err)</span><br><span class="line">getAscii, err := msg.GetAscii(1, 1)</span><br><span class="line">fmt.Println(getAscii, err)</span><br><span class="line">getByte, err := msg.GetByte(1, 2, 2)</span><br><span class="line">fmt.Println(getByte, err)</span><br><span class="line">getBoolean, err := msg.GetBoolean(1, 3, 1)</span><br><span class="line">fmt.Println(getBoolean, err)</span><br><span class="line">getFloat, err := msg.GetFloat(1, 4, 0)</span><br><span class="line">fmt.Println(getFloat, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test #0: S127F255 W H&lt;-&gt;E 消息名称, upper boundary, nested list node</span><br><span class="line">&lt;L[2]</span><br><span class="line">  &lt;L[1]</span><br><span class="line">    &lt;L[0]&gt;</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;L[5]</span><br><span class="line">    &lt;I1[2] 33 55&gt;</span><br><span class="line">    &lt;A &quot;test&quot;&gt;</span><br><span class="line">    &lt;B[3] 0b1 0b10 0b11111111&gt;</span><br><span class="line">    &lt;BOOLEAN[3] F T T&gt;</span><br><span class="line">    &lt;F4[3] -1.1 0 1&gt;</span><br><span class="line">  &gt;</span><br><span class="line">&gt;</span><br><span class="line">-------------------</span><br><span class="line">&lt;I1[2] 33 55&gt; &lt;nil&gt;</span><br><span class="line">55 &lt;nil&gt;</span><br><span class="line">test &lt;nil&gt;</span><br><span class="line">255 &lt;nil&gt;</span><br><span class="line">true &lt;nil&gt;</span><br><span class="line">-1.1 &lt;nil&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一篇算是有时间就补一下以前做的事。之前有提过Go有Encode/Decode SML/HSMS消息的库，该库对SECS2基协议解析基础完备的支持，易于使用的话需要对其进行一些细微的修改。&lt;/p&gt;
&lt;p&gt;这个库的学习可以通过各个文件的Test案例进行了解，基本上使用起来不会有太大的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="SECS/GEM - Go" scheme="chunlife.top/tags/SECS-GEM-Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实现HTTP到gRPC请求转换的最简单方法</title>
    <link href="chunlife.top/2023/05/18/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0HTTP%E5%88%B0gRPC%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/"/>
    <id>chunlife.top/2023/05/18/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0HTTP%E5%88%B0gRPC%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-18T13:07:40.000Z</published>
    <updated>2024-08-18T09:37:52.266Z</updated>
    
    <content type="html"><![CDATA[<p>上次我写了通过<code>protoreflect</code>的方法，自动代理服务，可以摆脱开proto文件的限制，这样网关可以将这些服务都自动代理起来。更进一步的，像现在微服务框架，如Kratos、ego、go-zero都兼顾根据proto文件上，根据<code>google/api/annotations.proto</code>增加的注解，生成HTTP的服务，而这些属性注释，网关都可以通过反射拿到，然后代理其HTTP。</p><p>除此之外，HTTP —&gt; Gateway —&gt; GRPC 有没有省事点的方法呢？可以直接将HTTP/1.1协议转成GRPC兼容，然后将返回再翻译为HTTP/1.1。</p><a id="more"></a><h3><span id="协议数据修改">协议数据修改</span></h3><p>这是偶然看到<a href="https://github.com/go-kratos/gateway" target="_blank" rel="noopener">go-kratos/gateway</a>中实现的http—&gt;h2所使用的技术。</p><p>这里利用了GRPC协议中为了兼容一些HTTP1.1端，在消息体的格式中，可使用<code>json</code>格式进行序列化（<code>application/grpc+json</code> ）。</p><p>在使用此 <strong>Content-Type</strong> 时，gRPC 服务器会将 JSON 格式的数据转换为 Protocol Buffers 格式的数据，然后进行处理。所以使用什么数据格式传输，并不影响其协议依然为HTTP/2。</p><h3><span id="代码分析">代码分析</span></h3><p>不想看代码，可以直接看<code>总结</code>中看如何实现的。</p><h4><span id="配置文件">配置文件</span></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a gateway config.</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">helloworld</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">middlewares:</span>                         <span class="string">公共的中间件，作用于所有路由</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">logging</span> </span><br><span class="line"><span class="attr">  - name:</span> <span class="string">transcoder</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">  - path:</span> <span class="string">/helloworld/*</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">1</span><span class="string">s</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">HTTP</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    backends:</span></span><br><span class="line"><span class="attr">      - target:</span> <span class="string">'127.0.0.1:8000'</span>     <span class="string">直连后端服务</span></span><br><span class="line"><span class="comment">#      - target: 'discovery:///bbs'</span></span><br><span class="line"><span class="attr">    middlewares:</span>                     <span class="string">私有中间件</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">circuitbreaker</span></span><br><span class="line"><span class="attr">        options:</span></span><br><span class="line">          <span class="string">'@type'</span><span class="string">:</span> <span class="string">type.googleapis.com/gateway.middleware.circuitbreaker.v1.CircuitBreaker</span></span><br><span class="line"><span class="attr">          successRatio:</span> <span class="string">&#123;"success":0.6,</span> <span class="string">"request"</span><span class="string">:"1",</span> <span class="string">"bucket"</span><span class="string">:"10",</span> <span class="string">"window"</span><span class="string">:"3s"&#125;</span></span><br><span class="line"><span class="attr">          backupService:</span> <span class="string">&#123;"endpoint":&#123;"backends":[&#123;"target":"127.0.0.1:8001"&#125;]&#125;&#125;</span></span><br><span class="line"><span class="attr">          assertCondtions:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">&#123;"by_status_code":"200"&#125;</span></span><br><span class="line"><span class="attr">  - path:</span> <span class="string">/helloworld.Greeter/*</span></span><br><span class="line"><span class="attr">    method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">1</span><span class="string">s</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">GRPC</span>                   <span class="string">协议，将决定gateway以什么样的client去请求后端服务</span></span><br><span class="line"><span class="attr">    backends:</span></span><br><span class="line"><span class="attr">      - target:</span> <span class="string">'127.0.0.1:9000'</span></span><br><span class="line"><span class="attr">    retry:</span></span><br><span class="line"><span class="attr">      attempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      perTryTimeout:</span> <span class="number">0.1</span><span class="string">s</span></span><br><span class="line"><span class="attr">      conditions:</span></span><br><span class="line"><span class="attr">        - byStatusCode:</span> <span class="string">'502-504'</span></span><br><span class="line"><span class="attr">        - byHeader:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">'Grpc-Status'</span></span><br><span class="line"><span class="attr">            value:</span> <span class="string">'14'</span></span><br></pre></td></tr></table></figure><h4><span id="proxy构建">proxy构建</span></h4><p>这里来看下来看下kratos-gateway的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>-kratos/gateway/cmd/gateway/main.<span class="keyword">go</span></span><br><span class="line">clientFactory := client.NewFactory(makeDiscovery())</span><br><span class="line"><span class="keyword">go</span>-kratos/gateway/client/factory.<span class="keyword">go</span>   返回一个client生成的工厂函数，用于生成请求Grpc或http的client，根据config上定义的endpoint。</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFactory new a client factory.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFactory</span><span class="params">(r registry.Discovery, opts ...Option)</span> <span class="title">Factory</span></span> &#123;</span><br><span class="line">o := &amp;options&#123;</span><br><span class="line">pickerBuilder: p2c.NewBuilder(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(o)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(endpoint *config.Endpoint)</span> <span class="params">(http.RoundTripper, error)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 负载均衡选择实例</span></span><br><span class="line">picker := o.pickerBuilder.Build()</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">applier := &amp;nodeApplier&#123;</span><br><span class="line">cancel:   cancel,</span><br><span class="line">endpoint: endpoint,</span><br><span class="line">registry: r,</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 创建client实例</span></span><br><span class="line"><span class="keyword">if</span> err := applier.apply(ctx, picker); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newClient(applier, picker), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// applier.apply</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(na *nodeApplier)</span> <span class="title">apply</span><span class="params">(ctx context.Context, dst selector.Selector)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nodes []selector.Node</span><br><span class="line"><span class="keyword">for</span> _, backend := <span class="keyword">range</span> na.endpoint.Backends &#123;</span><br><span class="line">target, err := parseTarget(backend.Target)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">switch</span> target.Scheme &#123;</span><br><span class="line">        <span class="comment">// - target: '127.0.0.1:8000'</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"direct"</span>:</span><br><span class="line">node := newNode(backend.Target, na.endpoint.Protocol, weighted, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;)</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, node)</span><br><span class="line">dst.Apply(nodes)</span><br><span class="line">        <span class="comment">// #      - target: 'discovery:///bbs'</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"discovery"</span>:</span><br><span class="line">....</span><br><span class="line">            </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"unknown scheme: %s"</span>, target.Scheme)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newNode，创建http/2或http/1.1的客户端    config中配置了GRPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNode</span><span class="params">(addr <span class="keyword">string</span>, protocol config.Protocol, weight *<span class="keyword">int64</span>, md <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">node := &amp;node&#123;</span><br><span class="line">protocol: protocol,</span><br><span class="line">address:  addr,</span><br><span class="line">weight:   weight,</span><br><span class="line">metadata: md,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> protocol == config.Protocol_GRPC &#123;</span><br><span class="line">node.client = _globalH2Client</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.client = _globalClient</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultH2Client</span><span class="params">()</span> *<span class="title">http</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;http.Client&#123;</span><br><span class="line">CheckRedirect: defaultCheckRedirect,</span><br><span class="line">Transport: &amp;http2.Transport&#123;</span><br><span class="line"><span class="comment">// So http2.Transport doesn't complain the URL scheme isn't 'https'</span></span><br><span class="line">AllowHTTP:          <span class="literal">true</span>,</span><br><span class="line">DisableCompression: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// Pretend we are dialing a TLS endpoint.</span></span><br><span class="line"><span class="comment">// Note, we ignore the passed tls.Config</span></span><br><span class="line">DialTLS: <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>, cfg *tls.Config)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> net.DialTimeout(network, addr, _dialTimeout)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了库<code>net/http2</code>，是Golang标准库中用于支持HTTP/2协议的包，它提供了HTTP/2客户端和服务器的实现，以及与HTTP/1.x的兼容性支持。</p><p>从这里也就能看到实际上在gateway中的客户端请求的实例了，gateway通过它来请求到后端实际的服务。到这里还得看HTTP request是怎么转化到GRPC请求的。</p><p>继续看Gateway怎么构建proxy的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>-kratos/gateway/cmd/gateway/main.<span class="keyword">go</span></span><br><span class="line">p.Update(bc)   根据配置路由信息，进行构建</span><br><span class="line">buildEndpoint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Proxy)</span> <span class="title">buildEndpoint</span><span class="params">(e *config.Endpoint, ms []*config.Middleware)</span> <span class="params">(http.Handler, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 生成实际访问的客户端实例</span></span><br><span class="line">    tripper, err := p.clientFactory(e)</span><br><span class="line"><span class="comment">// 实例请求时增加拦截函数（公有的，log、trace、熔断器等）</span></span><br><span class="line">tripper, err = p.buildMiddleware(e.Middlewares, tripper)</span><br><span class="line"><span class="comment">// 实例请求时增加拦截函数（私有，为这一路由独有的）</span></span><br><span class="line">tripper, err = p.buildMiddleware(ms, tripper)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> http.Handler(http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line">setXFFHeader(req)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把config信息带到每一个中间件函数中</span></span><br><span class="line">reqOpts := middleware.NewRequestOptions(e)</span><br><span class="line">ctx := middleware.NewRequestContext(req.Context(), reqOpts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resp *http.Response</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; retryStrategy.attempts; i++ &#123;</span><br><span class="line">......</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 实际请求的地方，会从中间件一层一层请求到实际的client请求后端服务</span></span><br><span class="line">resp, err = tripper.RoundTrip(req.Clone(tryCtx))</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doCopyBody := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">            </span><br><span class="line">....</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">doCopyBody()</span><br><span class="line">requestsTotalIncr(labels, resp.StatusCode)</span><br><span class="line">&#125;)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="请求协议转化">请求—协议转化</span></h4><p>实际请求时， 将进行协议中间件进行转化。</p><p>协议转化在<a href="https://github.com/go-kratos/gateway/blob/main/middleware/transcoder/transcoder.go" target="_blank" rel="noopener">go-kratos/gateway/middleware/transcoder/transcoder.go</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Middleware is a gRPC transcoder.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Middleware</span><span class="params">(c *config.Middleware)</span> <span class="params">(middleware.Middleware, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next http.RoundTripper)</span> <span class="title">http</span>.<span class="title">RoundTripper</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> middleware.RoundTripperFunc(<span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line">ctx := req.Context()</span><br><span class="line">contentType := req.Header.Get(<span class="string">"Content-Type"</span>)</span><br><span class="line">            <span class="comment">// 拿到配置信息</span></span><br><span class="line">endpoint, _ := middleware.EndpointFromContext(ctx)</span><br><span class="line">            <span class="comment">// 该路由请求到的后端服务是否为GRPC，是或者其请求格式已经为GRPC，不需要进行下面转化操作</span></span><br><span class="line"><span class="keyword">if</span> endpoint.Protocol != config.Protocol_GRPC || strings.HasPrefix(contentType, <span class="string">"application/grpc"</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> next.RoundTrip(req)</span><br><span class="line">&#125;</span><br><span class="line">b, err := io.ReadAll(req.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">bb := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b)+<span class="number">5</span>)</span><br><span class="line">binary.BigEndian.PutUint32(bb[<span class="number">1</span>:], <span class="keyword">uint32</span>(<span class="built_in">len</span>(b)))</span><br><span class="line"><span class="built_in">copy</span>(bb[<span class="number">5</span>:], b)</span><br><span class="line"><span class="comment">// content-type:</span></span><br><span class="line"><span class="comment">// - application/grpc+json</span></span><br><span class="line"><span class="comment">// - application/grpc+proto</span></span><br><span class="line">            <span class="comment">// 将数据格式的定义进行转化</span></span><br><span class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/grpc+"</span>+strings.TrimLeft(contentType, <span class="string">"application/"</span>))</span><br><span class="line">req.Header.Del(<span class="string">"Content-Length"</span>)</span><br><span class="line">req.ContentLength = <span class="keyword">int64</span>(<span class="built_in">len</span>(bb))</span><br><span class="line">req.Body = ioutil.NopCloser(bytes.NewReader(bb))</span><br><span class="line">resp, err := next.RoundTrip(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">data, err := io.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Convert HTTP/2 response to HTTP/1.1</span></span><br><span class="line"><span class="comment">// Trailers are sent in a data frame, so don't announce trailers as otherwise downstream proxies might get confused.</span></span><br><span class="line">            <span class="comment">// HTTP trailers是HTTP消息的一部分，用于传输HTTP消息的元数据，例如消息的哈希值、压缩信息或长度等。</span></span><br><span class="line"><span class="keyword">for</span> trailerName, values := <span class="keyword">range</span> resp.Trailer &#123;</span><br><span class="line">resp.Header[trailerName] = values</span><br><span class="line">&#125;</span><br><span class="line">resp.Trailer = <span class="literal">nil</span></span><br><span class="line">resp.Header.Set(<span class="string">"Content-Type"</span>, contentType)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不为0即异常。grpc-status转化为http code，错误详情：grpc-status-details-bin，grpc-message</span></span><br><span class="line">            <span class="comment">// grpc-status-details-bin是一个二进制元数据，它包含有关gRPC调用失败的更多详细信息，例如错误代码、错误消息和堆栈跟踪等。这些详细信息可以由gRPC客户端用于诊断和调试问题。</span></span><br><span class="line"><span class="comment">// grpc-message是一个字符串元数据，其中包含有关gRPC调用失败的简要信息，例如错误消息。它通常用于向终端用户报告错误。</span></span><br><span class="line"><span class="comment">// 当gRPC调用失败时，gRPC服务器会将grpc-status-details-bin和grpc-message元数据作为响应的一部分发送回gRPC客户端。客户端可以访问这些元数据，以了解有关失败的更多信息，以及如何解决问题。</span></span><br><span class="line"><span class="keyword">if</span> grpcStatus := resp.Header.Get(<span class="string">"grpc-status"</span>); grpcStatus != <span class="string">"0"</span> &#123;</span><br><span class="line">code, err := strconv.ParseInt(grpcStatus, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">st := &amp;spb.Status&#123;</span><br><span class="line">Code:    <span class="keyword">int32</span>(code),</span><br><span class="line">Message: resp.Header.Get(<span class="string">"grpc-message"</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> grpcDetails := resp.Header.Get(<span class="string">"grpc-status-details-bin"</span>); grpcDetails != <span class="string">""</span> &#123;</span><br><span class="line">details, err := decodeBinHeader(grpcDetails)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = proto.Unmarshal(details, st); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data, err := protojson.Marshal(st)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newResponse(<span class="number">200</span>, resp.Header, data)</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// grpc返回数据前5个字节代表数据长度。</span></span><br><span class="line">resp.Body = ioutil.NopCloser(bytes.NewReader(data[<span class="number">5</span>:]))</span><br><span class="line">resp.ContentLength = <span class="keyword">int64</span>(<span class="built_in">len</span>(data) - <span class="number">5</span>)</span><br><span class="line"><span class="comment">// Any content length that might be set is no longer accurate because of trailers.</span></span><br><span class="line">            <span class="comment">// 不再准确的原因是，HTTP/2的header是不体现在length，所以不能单纯的直接进行替换</span></span><br><span class="line">resp.Header.Del(<span class="string">"Content-Length"</span>)</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="总结">总结</span></h3><p>通过GRPC协议中为了兼容HTTP/1.1协议所给出传输格式<code>application/grpc+json</code>，使用<code>golang.org/x/net/http2</code>，通过修改HTTP请求头，可以做到使用HTTP访问到GRPC服务。以下是更简略的版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_defaultH2Client</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cli := &amp;http.Client&#123;</span><br><span class="line">CheckRedirect: defaultCheckRedirect,</span><br><span class="line">Transport: &amp;http2.Transport&#123;</span><br><span class="line"><span class="comment">// So http2.Transport doesn't complain the URL scheme isn't 'https'</span></span><br><span class="line">AllowHTTP:          <span class="literal">true</span>,</span><br><span class="line">DisableCompression: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// Pretend we are dialing a TLS endpoint.</span></span><br><span class="line"><span class="comment">// Note, we ignore the passed tls.Config</span></span><br><span class="line">DialTLS: <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>, cfg *tls.Config)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> net.DialTimeout(network, addr, _dialTimeout)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := cli.Post(<span class="string">"http://127.0.0.1:9000/helloworld.Greeter/SayHello"</span>,</span><br><span class="line"><span class="string">"application/grpc+json"</span>, strings.NewReader(<span class="string">`&#123;"hello": "2131"&#125;`</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(resp.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次我写了通过&lt;code&gt;protoreflect&lt;/code&gt;的方法，自动代理服务，可以摆脱开proto文件的限制，这样网关可以将这些服务都自动代理起来。更进一步的，像现在微服务框架，如Kratos、ego、go-zero都兼顾根据proto文件上，根据&lt;code&gt;google/api/annotations.proto&lt;/code&gt;增加的注解，生成HTTP的服务，而这些属性注释，网关都可以通过反射拿到，然后代理其HTTP。&lt;/p&gt;
&lt;p&gt;除此之外，HTTP —&amp;gt; Gateway —&amp;gt; GRPC 有没有省事点的方法呢？可以直接将HTTP/1.1协议转成GRPC兼容，然后将返回再翻译为HTTP/1.1。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="Go" scheme="chunlife.top/tags/Go/"/>
    
    <category term="GRPC" scheme="chunlife.top/tags/GRPC/"/>
    
  </entry>
  
  <entry>
    <title>自动mock grpc服务</title>
    <link href="chunlife.top/2023/04/01/%E8%87%AA%E5%8A%A8mock-grpc%E6%9C%8D%E5%8A%A1/"/>
    <id>chunlife.top/2023/04/01/%E8%87%AA%E5%8A%A8mock-grpc%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-04-01T09:51:27.000Z</published>
    <updated>2024-08-18T09:37:52.334Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，在编写GRPC服务应用时，需要获取相应的proto文件，生成server、client的打桩代码，借此即可访问服务，同时也能启动服务，但这里会有个问题，就是需要获取到对应的proto文件。我想直接知道对方的请求参数和返回参数，并由此来设定mock值，设定完成后，即可直接请求。</p><p>基于以上的需要，进行相应的实现，即可得到所需的效果。</p><a id="more"></a><h3><span id="动态获取proto">动态获取proto</span></h3><p>通过接口获取对应服务proto定义的能力，需要对方服务打开proto 反射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer()</span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">log.Printf(<span class="string">"server listening at %v"</span>, lis.Addr())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register reflection service on gRPC server.  "google.golang.org/grpc/reflection"</span></span><br><span class="line">reflection.Register(s)</span><br></pre></td></tr></table></figure><p><code>Register</code>其实是注册一个服务，里面就一个函数，可以拿到该proto的所有数据，如同在自己的项目中调用<code>reflection</code>库一般。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register registers the server reflection service on the given gRPC server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(s GRPCServer)</span></span> &#123;</span><br><span class="line">svr := NewServer(ServerOptions&#123;Services: s&#125;)</span><br><span class="line">v1alphagrpc.RegisterServerReflectionServer(s, svr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="启动server">启动server</span></h3><p>启动一个可以接受任何请求的<code>GRPC</code>服务器，这里做一步如同<code>grpc proxy</code>的操作，不去注册固定的服务处理函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(grpc.UnknownServiceHandler(<span class="function"><span class="keyword">func</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, stream grpc.ServerStream)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取请求流的目的 Method 名称</span></span><br><span class="line">fullMethodName, ok := grpc.MethodFromServerStream(stream)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"failed to get method from server stream"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fullMethodName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定该服务是否已被注册，并找到准备好的返回值</span></span><br><span class="line">resp, err := director(fullMethodName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> status.Errorf(codes.InvalidArgument, <span class="string">"failed find string"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将其发回去</span></span><br><span class="line">err = stream.SendMsg(resp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"send msg error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;))</span><br><span class="line">err = s.Serve(listener)</span><br></pre></td></tr></table></figure><h3><span id="使用">使用</span></h3><p>在前端界面上输入目标服务器的地址，获取到其接口和参数，然后填入mock值。</p><p>新增的功能：</p><ul><li>自动生成参数，根据值类型；（像例如<code>yapi</code>）</li><li>引入表达式，可以根据表达式对请求参数和返回值做一些灵活操作</li><li>加入到注册中心，自动mock所有可被mock的服务</li></ul><h3><span id="参考">参考</span></h3><p><a href="https://github.com/fullstorydev/grpcurl" target="_blank" rel="noopener">grpcurl</a></p><p><a href="https://github.com/jhump/protoreflect" target="_blank" rel="noopener">protoreflect</a></p><p><a href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-08-grpcurl.html#48-grpcurl-%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">grpcurl-工具</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，在编写GRPC服务应用时，需要获取相应的proto文件，生成server、client的打桩代码，借此即可访问服务，同时也能启动服务，但这里会有个问题，就是需要获取到对应的proto文件。我想直接知道对方的请求参数和返回参数，并由此来设定mock值，设定完成后，即可直接请求。&lt;/p&gt;
&lt;p&gt;基于以上的需要，进行相应的实现，即可得到所需的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="Go" scheme="chunlife.top/tags/Go/"/>
    
    <category term="GRPC" scheme="chunlife.top/tags/GRPC/"/>
    
  </entry>
  
  <entry>
    <title>SECS/GEM协议学习</title>
    <link href="chunlife.top/2023/02/22/SECS-GEM%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>chunlife.top/2023/02/22/SECS-GEM%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-22T09:10:31.000Z</published>
    <updated>2023-04-01T09:49:00.978Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="开源">开源</span></h3><p>SECS/GEM 的库市面上是有开源软件可选的。例如：</p><a id="more"></a><p>Python：</p><p><a href="https://github.com/bparzella/secsgem" target="_blank" rel="noopener">bparzella/secsgem</a></p><p><a href="https://github.com/kenta-shimizu/pysemisecs" target="_blank" rel="noopener">kenta-shimizu/pysemisecs</a></p><p>C#：</p><p><a href="https://github.com/mkjeff/secs4net" target="_blank" rel="noopener">mkjeff/secs4net</a></p><p>Java：</p><p><a href="https://github.com/kenta-shimizu/secs4java8" target="_blank" rel="noopener">kenta-shimizu/secs4java8</a></p><h3><span id="资料">资料</span></h3><p>基础知识了解：</p><p><a href="https://blog.csdn.net/jxb_memory/category_9885599.html" target="_blank" rel="noopener">https://blog.csdn.net/jxb_memory/category_9885599.html</a></p><p>视频资料：</p><p><a href="https://www.bilibili.com/video/BV1MU4y1v7hT/?spm_id_from=333.999.0.0&amp;vd_source=b670da3ecf6c8ddc9d65e67a875bde18" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1MU4y1v7hT/?spm_id_from=333.999.0.0&amp;vd_source=b670da3ecf6c8ddc9d65e67a875bde18</a></p><h3><span id="实践过程">实践过程</span></h3><p>对于新了解的协议还是比较好奇的，特别是Go中没有其实现。（工业软件中Go还是没有什么可以插足的）</p><p>闲来无事，对基础协议进行一定量的开发，算是对协议的一个了解过程。其中，解析协议内容使用库<a href="https://github.com/wolimst/lib-secs2-hsms-go" target="_blank" rel="noopener">wolimst/lib-secs2-hsms-go</a>。另外的操作就是对TCP连接的管理，以及针对协议中提到的几个Timeout时间，体现在协议中。在此基础就能实现大体协议的内容。</p><p>ID间的联系：</p><p><img src="image-20230227100537493.png" alt="ID关系图示"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DeviceID(SessionID)：用于Host识别的设备号。</span><br><span class="line"></span><br><span class="line">CEID:event ID 即事件ID</span><br><span class="line"></span><br><span class="line">SVID:设备状态变量ID</span><br><span class="line"></span><br><span class="line">ECID:设备常量ID</span><br><span class="line"></span><br><span class="line">VID ：变量ID</span><br><span class="line"></span><br><span class="line">RPTID：report ID 即上报ID</span><br><span class="line"></span><br><span class="line">PPID：recipe ID 即配方ID（工艺ID）</span><br><span class="line"></span><br><span class="line">CHIPID：芯片ID</span><br></pre></td></tr></table></figure><p>在实际做库的过程中，可以将各类数据都转化到一个层级进行管理，用各类map都搜集起来，这样数据的读和取都是统一对此层级负责的，也是只能从这层数据中拿到操作的，数据一致性也有所保证。</p><hr><p>至于Go中直接调用Python，或其他语言编成库等形式，应该也是可以尝试的。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;开源&quot;&gt;开源&lt;/h3&gt;
&lt;p&gt;SECS/GEM 的库市面上是有开源软件可选的。例如：&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="Go" scheme="chunlife.top/tags/Go/"/>
    
    <category term="SECS/GEM" scheme="chunlife.top/tags/SECS-GEM/"/>
    
  </entry>
  
  <entry>
    <title>Golang oracle使用</title>
    <link href="chunlife.top/2022/10/27/Golang-oracle%E4%BD%BF%E7%94%A8/"/>
    <id>chunlife.top/2022/10/27/Golang-oracle%E4%BD%BF%E7%94%A8/</id>
    <published>2022-10-27T07:05:38.000Z</published>
    <updated>2023-04-01T09:49:00.974Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Go</code>语言中，对<code>Oracle</code>进行操作，比访问其他常见DB可谓是要麻烦一些，显而易见的问题是库的选择，这里我尝试了两种库：</p><ul><li><p><a href="https://github.com/sijms/go-ora" target="_blank" rel="noopener">go-ora</a> + 官方库database/sql （<a href="http://github.com/jmoiron/sqlx%E3%80%81github.com/blockloop/scan" target="_blank" rel="noopener">github.com/jmoiron/sqlx、github.com/blockloop/scan</a> 辅助）</p></li><li><p><a href="https://github.com/mattn/go-oci8" target="_blank" rel="noopener">go-oci8</a> + <a href="https://gitea.com/xorm/xorm" target="_blank" rel="noopener">xorm</a></p></li></ul><h2><span id="库的选择">库的选择</span></h2><p><code>go-ora</code>是原生Go实现的，不需要依赖CGo，相对比较方便，也比较易用，但在使用过程中，使用该库连接Oracle一段时间后，其会请求出错，我也对此提了<code>issue</code>，以及解决方法，但由于联系不上<code>maintainer</code>，所以无法确认解决方法是否靠谱了。</p><p><a href="https://github.com/sijms/go-ora/issues/240" target="_blank" rel="noopener">https://github.com/sijms/go-ora/issues/240</a></p><blockquote><p>也有人遇到了与我相似的问题，用我issue上提到的解决方式解决了该问题，但我依然不推荐这么操作。</p></blockquote><p><code>go-oci8</code>是使用了CGo实现了Oracle的客户端，虽然对环境有所依赖，好在库很稳定，不用担心出幺蛾子，且<code>xorm</code>实验性的支持，对只使用oracle基础功能来说，还是够用的。</p><p>推荐使用下面这种。</p><h2><span id="sql使用">SQL使用</span></h2><h3><span id="大小写">大小写</span></h3><p>在使用<code>oracle</code> Console时，输入表名、字段，不管大小写都可以识别。但其实这里有个误区。</p><p><code>Oracle默认是大写的</code>，也就是说在没有使用双引号<code>&quot;</code>对表名和列名进行限定的时候，表名不过是小写还是大写，最后都默认成了大写。</p><p>若是以<strong>双引号</strong>进行限定后，字段大小写就不再转化为默认的大写了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> department (</span><br><span class="line">     <span class="keyword">id</span>           <span class="built_in">NUMBER</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     DESCRIPTION  VARCHAR2(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>上面字段都会转化为大写，<code>DEPARTMENT</code>，<code>ID</code>，<code>DESCRIPTION</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> department;     √</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> department;     √</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">"id"</span> <span class="keyword">FROM</span> department;   ×</span><br></pre></td></tr></table></figure><p>明白上述所述后，使用<code>xorm</code>时需要注意的是。</p><p>在使用xorm自动创建表时，其会根据你的注释的大小写，创建字段。这里就要区分一下了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">Type <span class="keyword">int8</span> <span class="string">`json:"type,omitempty" xorm:"number(8) 'type'"`</span></span><br><span class="line">Sn <span class="keyword">string</span> <span class="string">`json:"sn,omitempty" xorm:"varchar2(64) 'sn'"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="时间">时间</span></h3><p>对时区的设置，这里是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE SET TIME_ZONE=&apos;Asia/Shanghai&apos;;</span><br><span class="line">ALTER SESSION SET TIME_ZONE =&apos;Asia/Shanghai&apos;;</span><br></pre></td></tr></table></figure><p><code>update_time</code>、<code>created_time</code>常见的两个时间，保存时间戳是没有什么问题(<code>int64</code>)。但要保存time时间格式，估计会发现没法存进去。</p><p><code>update_time</code>可以使用raw sql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE xxxx SET &quot;max_id&quot;=&quot;max_id&quot; + &quot;step&quot;, &quot;update_time&quot; = TO_TIMESTAMP(&apos;%s&apos;, &apos;YYYY-MM-DD HH24:MI:SS.FF6&apos;) WHERE &quot;biz_tag&quot;=&apos;123&apos;</span><br><span class="line"></span><br><span class="line">时间传入：time.Unix(time.Now().Unix(), 0).Format(&quot;2006-01-02 15:04:05.0000&quot;)</span><br></pre></td></tr></table></figure><hr><p><code>created_time</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &quot;xxxxxx&quot;(</span><br><span class="line">    &quot;id&quot; NUMBER DEFAULT 1,</span><br><span class="line">    &quot;created_time&quot; TIMESTAMP WITH LOCAL TIME ZONE DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line"></span><br><span class="line">    PRIMARY KEY(&quot;id&quot;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type xxxxx struct &#123;</span><br><span class="line">CreatedTime      time.Time `json:&quot;created_time,omitempty&quot; xorm:&quot;TIMESTAMP(6) WITH LOCAL TIME ZONE default CURRENT_TIMESTAMP &apos;created_time&apos;&quot;` // 记录创建时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="主键">主键</span></h3><p>12版本以前没法像<code>MySQL</code>一样生成自增主键，需要一些曲线救国的方式。</p><p>使用<code>SYS_GUID()</code>，系统根据当前时间和机器码，生成全球唯一的一个序列号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE department (</span><br><span class="line">     ID       varchar2(50)     default SYS_GUID() not null primary key,</span><br><span class="line">     DESCRIPTION  VARCHAR2(50)  NOT NULL);</span><br></pre></td></tr></table></figure><p>自增ID的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Oracle 12c之前：</span><br><span class="line">-- 表定义</span><br><span class="line">CREATE TABLE departments (</span><br><span class="line">     ID           NUMBER(10)    NOT NULL,</span><br><span class="line">     DESCRIPTION  VARCHAR2(50)  NOT NULL);</span><br><span class="line"></span><br><span class="line">ALTER TABLE departments ADD (</span><br><span class="line">    CONSTRAINT dept_pk PRIMARY KEY (ID));</span><br><span class="line"></span><br><span class="line">CREATE SEQUENCE dept_seq START WITH 1;</span><br><span class="line"></span><br><span class="line">-- 触发器定义</span><br><span class="line">CREATE OR REPLACE TRIGGER dept_bir</span><br><span class="line">    BEFORE INSERT ON departments</span><br><span class="line">    FOR EACH ROW</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">    SELECT dept_seq.NEXTVAL</span><br><span class="line">    INTO   :new.id</span><br><span class="line">    FROM   dual;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">12c：</span><br><span class="line">CREATE TABLE MAPS</span><br><span class="line">(</span><br><span class="line">  MAP_ID INTEGER GENERATED ALWAYS AS IDENTITY (START WITH 1 INCREMENT BY 1) NOT NULL,</span><br><span class="line">  MAP_NAME VARCHAR(24) NOT NULL,</span><br><span class="line">  UNIQUE (MAP_ID, MAP_NAME)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;code&gt;Go&lt;/code&gt;语言中，对&lt;code&gt;Oracle&lt;/code&gt;进行操作，比访问其他常见DB可谓是要麻烦一些，显而易见的问题是库的选择，这里我尝试了两种库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sijms</summary>
      
    
    
    
    <category term="DB" scheme="chunlife.top/categories/DB/"/>
    
    
    <category term="oracle" scheme="chunlife.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Yapi的安装以及使用</title>
    <link href="chunlife.top/2022/07/21/Yapi%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>chunlife.top/2022/07/21/Yapi%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2022-07-21T06:05:32.000Z</published>
    <updated>2023-02-25T10:49:35.507Z</updated>
    
    <content type="html"><![CDATA[<p>内网部署可综合管理并利于测试的工具——<code>Yapi</code>。</p><p>在使用上，官方文档已经很清晰了，<a href="https://hellosean1025.github.io/yapi/documents/index.html" target="_blank" rel="noopener">文档</a>。</p><p>文章主要功夫是写一下安装环节遇到的问题，主要是项目年久失修，而各路环境又是突飞猛进的进行改变，所以造成其有兼容性问题。</p><h3><span id="容器环境">容器环境</span></h3><p>docker部署<code>yapi</code>是极其方便易用的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 账号：admin@docker.yapi</span></span><br><span class="line"><span class="comment"># 密码：adm1n</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  yapi-web:</span><br><span class="line">    image: jayfong/yapi:<span class="number">1.10</span>.<span class="number">2</span></span><br><span class="line">    container_name: yapi-web</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">40001</span>:<span class="number">3000</span></span><br><span class="line">    environment:</span><br><span class="line">      - YAPI_ADMIN_ACCOUNT=admin@docker.yapi</span><br><span class="line">      - YAPI_ADMIN_PASSWORD=adm1n</span><br><span class="line">      - YAPI_CLOSE_REGISTER=true</span><br><span class="line">      - YAPI_DB_SERVERNAME=yapi-mongo</span><br><span class="line">      - YAPI_DB_PORT=<span class="number">27017</span></span><br><span class="line">      - YAPI_DB_DATABASE=yapi</span><br><span class="line">      - YAPI_MAIL_ENABLE=false</span><br><span class="line">      - YAPI_LDAP_LOGIN_ENABLE=false</span><br><span class="line">      - YAPI_PLUGINS=[&#123;<span class="string">"name"</span>:<span class="string">"interface-oauth2-token"</span>,<span class="string">"name"</span>:<span class="string">"add-user"</span>&#125;]</span><br><span class="line">    depends_on:</span><br><span class="line">      - yapi-mongo</span><br><span class="line">    links:</span><br><span class="line">      - yapi-mongo</span><br><span class="line">    restart: unless-stopped</span><br><span class="line">  yapi-mongo:</span><br><span class="line">    image: mongo:<span class="number">4.4</span>.<span class="number">4</span></span><br><span class="line">    container_name: yapi-mongo</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/db:/data/db</span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="number">27017</span></span><br><span class="line">    restart: unless-stopped</span><br></pre></td></tr></table></figure><p>但这里面会碰到一个问题，在使用mock测试集的时候会碰到<code>safeify</code>引发的<code>Error: EROFS: read-only file system</code>问题，跟着<a href="https://github.com/YMFE/yapi/issues/2376" target="_blank" rel="noopener">#2376</a>修改完成之后，使用<code>assert</code>依然会碰到<code>Error: Method Promise.prototype.then called on incompatible receiver [object Object]</code>。</p><p>该问题也被记录在<a href="https://github.com/YMFE/yapi/issues/2536" target="_blank" rel="noopener">#2536</a>。</p><p>解决方法当时未找到，这里就没有深究了。</p><h3><span id="本地部署">本地部署</span></h3><p>环境要求：</p><blockquote><p>Node.js（7.6+)</p><p>MongoDB（2.6+）</p></blockquote><p>当前node版本太高，<code>Yapi</code>需要一个低版本的<code>node</code>。</p><p>参考：<a href="https://jingyan.baidu.com/article/b2c186c86754afc46ef6ff04.html" target="_blank" rel="noopener">怎么在Ubuntu中更新node的版本</a>，安装工具n。使用工具n，指定版本安装，我这里安装的是12.16.3。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n 12.16.3</span><br></pre></td></tr></table></figure><p>参考<a href="https://hellosean1025.github.io/yapi/devops/index.html#%e5%ae%89%e8%a3%85" target="_blank" rel="noopener">官方安装文档</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir yapi</span><br><span class="line">cd yapi</span><br><span class="line">git clone https://github.com/YMFE/yapi.git vendors //或者下载 zip 包解压到 vendors 目录（clone 整个仓库大概 140+ M，可以通过 `git clone --depth=1 https://github.com/YMFE/yapi.git vendors` 命令减少，大概 10+ M）</span><br><span class="line"></span><br><span class="line">cp vendors/config_example.json ./config.json //复制完成后请修改相关配置</span><br><span class="line"></span><br><span class="line">cd vendors</span><br><span class="line">npm install --production --registry https://registry.npm.taobao.org</span><br><span class="line">npm run install-server //安装程序会初始化数据库索引和管理员账号，管理员账号名可在 config.json 配置</span><br><span class="line">node server/app.js //启动服务器后，请访问 127.0.0.1:&#123;config.json配置的端口&#125;，初次运行会有个编译的过程，请耐心等候</span><br></pre></td></tr></table></figure><p><code>config.json</code>中设置<code>MongoDB</code>的用户，需要MongoDB开启<code>auth</code>。</p><blockquote><p>注意，config.json的引用是在文件<code>server/yapi.js</code>中。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo:latest</span><br><span class="line">docker run -itd --name mongo -p 27017:27017 mongo --auth</span><br><span class="line"></span><br><span class="line">docker exec -it mongo mongo admin</span><br><span class="line"></span><br><span class="line">//进入admin。如果没有admin库，会自动创建admin库</span><br><span class="line">user admin</span><br><span class="line"></span><br><span class="line">//创建一个新账号 权限root</span><br><span class="line">db.createUser(&#123;user:&quot;test1&quot;,pwd:&quot;test1&quot;,roles:[&quot;root&quot;]&#125;)</span><br><span class="line">//创建一个新账号 用户名test1 密码test1 权限dbOwner 只能访问yapi数据库</span><br><span class="line">db.createUser(&#123;user:&quot;test1&quot;,pwd:&quot;test1&quot;,roles:[&#123;role:&apos;dbOwner&apos;,db:&apos;yapi&apos;&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">//账号授权：用户名 密码。 回车，返回1，认证成功。</span><br><span class="line">db.auth(&quot;test1&quot;,&quot;test1&quot;)</span><br></pre></td></tr></table></figure><p><code>config.json</code>中DB的设置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"db": &#123;                                                                                                                                               </span><br><span class="line">  "servername": "127.0.0.1",                                                                                                                          </span><br><span class="line">  "DATABASE": "yapi",                                                                                                                                 </span><br><span class="line">  "port": 27017,                                                                                                                                      </span><br><span class="line">  "user": "test1",                                                                                                                                    </span><br><span class="line">  "pass": "test1",                                                                                                                                    </span><br><span class="line">  "authSource": ""  // 若是为空验证失败，则填入admin试试                                                                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有新建完成后，<code>mock</code>会遇到新问题。</p><p><code>UnhandledPromiseRejectionWarning: TypeError: Converting circular structure to JSON</code></p><p>需要改动，<code>vendors/server/utils/sandbox.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Safeify = <span class="built_in">require</span>(<span class="string">'safeify'</span>).default;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sandboxFn</span>(<span class="params">context, script</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 safeify 实例</span></span><br><span class="line">    <span class="keyword">const</span> safeVm = <span class="keyword">new</span> Safeify(&#123;</span><br><span class="line">        timeout: <span class="number">3000</span>,</span><br><span class="line">        asyncTimeout: <span class="number">60000</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修复断言错误</span></span><br><span class="line">        unrestricted: <span class="literal">true</span>,</span><br><span class="line">        unsafe: &#123;</span><br><span class="line">            modules: &#123;</span><br><span class="line">                assert: <span class="string">'assert'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    safeVm.preset(<span class="string">'const assert= require("assert");'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决 https://github.com/YMFE/yapi/issues/2543, https://github.com/YMFE/yapi/issues/2357</span></span><br><span class="line">    script += <span class="string">`; return &#123;</span></span><br><span class="line"><span class="string">        Function: this.Function,</span></span><br><span class="line"><span class="string">        eval: this.eval,</span></span><br><span class="line"><span class="string">        header: this.header,</span></span><br><span class="line"><span class="string">        query: this.query,</span></span><br><span class="line"><span class="string">        body: this.body,</span></span><br><span class="line"><span class="string">        mockJson: this.mockJson,</span></span><br><span class="line"><span class="string">        params: this.params,</span></span><br><span class="line"><span class="string">        resHeader: this.resHeader,</span></span><br><span class="line"><span class="string">        httpCode: this.httpCode,</span></span><br><span class="line"><span class="string">        delay: this.delay,</span></span><br><span class="line"><span class="string">        Random: this.Random,</span></span><br><span class="line"><span class="string">        cookie: this.cookie</span></span><br><span class="line"><span class="string">    &#125;`</span>;</span><br><span class="line">    <span class="comment">// 执行动态代码</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> safeVm.run(script, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    safeVm.destroy()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="开启ldap">开启LDAP</span></h3><p>开启之后即可接通公司的账户体系。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"ldapLogin": &#123;                                                                                                                                           </span><br><span class="line">      "enable": true,                                                                                                                                    </span><br><span class="line">      "server": "ldap://xxxxxx:389",                                                                                                                 </span><br><span class="line">      "baseDn": "xxxx.xx",    // 账户体系中的用户名                                                                                                                    </span><br><span class="line">      "bindPassword": "xxxxx",                                                                                                                        </span><br><span class="line">      "searchDn": "DC=xxxx,DC=xxxx",                                                                                                               </span><br><span class="line">      "searchStandard": "&amp;(objectClass=user)(sAMAccountName=%s)",                                                                                        </span><br><span class="line">      "emailPostfix": "@xxxxxx.com",                                                                                                                    </span><br><span class="line">      "emailKey": "userPrincipalName",                                                                                                                   </span><br><span class="line">      "usernameKey": "cn"                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内网部署可综合管理并利于测试的工具——&lt;code&gt;Yapi&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在使用上，官方文档已经很清晰了，&lt;a href=&quot;https://hellosean1025.github.io/yapi/documents/index.html&quot; target=&quot;</summary>
      
    
    
    
    <category term="devops" scheme="chunlife.top/categories/devops/"/>
    
    
    <category term="yapi" scheme="chunlife.top/tags/yapi/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 实战45讲 学习笔记</title>
    <link href="chunlife.top/2022/06/24/MySQL-%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>chunlife.top/2022/06/24/MySQL-%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-24T03:07:59.000Z</published>
    <updated>2023-02-25T10:49:35.461Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL是Coder必备知识，最近我也是趁着自己有时间，看过一遍网络知识后，再回过头来看下MySQL，看MySQL的时候用到了Margin Note3，确实挺好用的，推荐学习时使用，电脑端使用book xnote。我会把思维导图丢到网页上来，也是方便我使用电脑查看。</p><p>MySQL学习推荐课程：<a href="https://time.geekbang.org/column/intro/139?tab=catalog" target="_blank" rel="noopener">MySQL 实战 45 讲</a></p><a id="more"></a><div class="row">    <embed src="MySQL 学习笔记_withMarginNotes.pdf" width="100%" height="550" type="application/pdf"></div><hr><h3><span id="问题手记">问题手记</span></h3><h4><span id="1-事务隔离级别引申出来的可见性问题若记录都未存在无行锁并发插入时无法按照预期进行更新">1、事务隔离级别引申出来的可见性问题，若记录都未存在，无行锁，并发插入时无法按照预期进行更新；</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`like`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`liker_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_user_id_liker_id`</span> (<span class="string">`user_id`</span>,<span class="string">`liker_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`friend`</span> (</span><br><span class="line">  <span class="keyword">id</span><span class="string">` int(11) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">  `</span>friend_1_id<span class="string">` int(11) NOT NULL,</span></span><br><span class="line"><span class="string">  `</span>firned_2_id<span class="string">` int(11) NOT NULL,</span></span><br><span class="line"><span class="string">  UNIQUE KEY `</span>uk_friend<span class="string">` (`</span>friend_1_id<span class="string">`,`</span>firned_2_id<span class="string">`)</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`</span><span class="keyword">id</span><span class="string">`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB;</span></span><br></pre></td></tr></table></figure><blockquote><p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行逻辑是这样的：</p></blockquote><blockquote><p>以A关注B为例：<br>第一步，先查询对方有没有关注自己（B有没有关注A）<br>select * from like where user_id = B and liker_id = A;</p></blockquote><blockquote><p>如果有，则成为好友<br>insert into friend;</p></blockquote><blockquote><p>没有，则只是单向关注关系<br>insert into like;</p></blockquote><blockquote><p>但是<strong>如果A、B同时关注对方</strong>，会出现不会成为好友的情况。因为上面第1步，双方都没关注对方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在MySQL锁层面有没有办法处理？</p></blockquote><p>如图：</p><img src="c45063baf1ae521bf5d98b6d7c0e0ced.png" alt="并发“喜欢”逻辑操作顺序" style="zoom: 50%;"><p>A、B之间没有关注关系（没有记录），事务开始时，查询为空。</p><p>对业务来说，双方已经互点关注了，已经不是<code>喜欢</code>了，而是需要在<code>friend</code>表中插入记录。</p><p>如图示中，在进行查询时，选择的数据加上行锁也没啥用，毕竟在查询的时候数据都还不存在。</p><p>首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。</p><blockquote><p>值是1的时候，表示user_id 关注 liker_id;    0b01<br>值是2的时候，表示liker_id 关注 user_id;    0b10<br>值是3的时候，表示互相关注。                     0b11</p></blockquote><p>然后，当 A关注B的时候，逻辑改成如下所示的样子：</p><p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin; /*启动事务*/</span><br><span class="line">insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;</span><br><span class="line">select relation_ship from `like` where user_id=A and liker_id=B;</span><br><span class="line">/*代码中判断返回的 relation_ship，</span><br><span class="line">  如果是1，事务结束，执行 commit</span><br><span class="line">  如果是3，则执行下面这两个语句：</span><br><span class="line">  */</span><br><span class="line">insert ignore into friend(friend_1_id, friend_2_id) values(A,B);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>如果A&gt;B，则执行下面的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin; /*启动事务*/</span><br><span class="line">insert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;</span><br><span class="line">select relation_ship from `like` where user_id=B and liker_id=A;</span><br><span class="line">/*代码中判断返回的 relation_ship，</span><br><span class="line">  如果是2，事务结束，执行 commit</span><br><span class="line">  如果是3，则执行下面这两个语句：</span><br><span class="line">*/</span><br><span class="line">insert ignore into friend(friend_1_id, friend_2_id) values(B,A);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。</p><blockquote><p>把正反向的数据都转化到一行记录里面，而不是分开（通过A、B UserID的大小）</p></blockquote><p>然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。</p><blockquote><p>事务在执行第一条语句时开启，开启后，碰到<code>insert … on duplicate语句</code>（先判断记录是否存在，存在即update，不存在即insert）,修改语句，占用该行锁直到事务结束。（占不住则意味着要等待别人把该记录的行锁释放，也就是另外的事务结束）</p></blockquote><p>操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。</p><blockquote><p>insert ignore into，重复则忽略，不重复则插入。（重复时只是报警，不会报错）</p></blockquote><p>这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。</p><hr><p>这里的问题就是事务隔离引申出来的问题，“可见性”。当数据都还未出现呢，此时不管是<code>当前读</code>，还是<code>快照读</code>都得眼瞎。</p><p>解决此问题，依然还是用到了行锁，精妙的地方是，利用了<code>insert … on duplicate</code>语句，创建与更新同时存在，后面的查询语句去<strong>更新验证结果</strong>，由于两阶段锁协议，所以查询语句也是带锁的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL是Coder必备知识，最近我也是趁着自己有时间，看过一遍网络知识后，再回过头来看下MySQL，看MySQL的时候用到了Margin Note3，确实挺好用的，推荐学习时使用，电脑端使用book xnote。我会把思维导图丢到网页上来，也是方便我使用电脑查看。&lt;/p&gt;
&lt;p&gt;MySQL学习推荐课程：&lt;a href=&quot;https://time.geekbang.org/column/intro/139?tab=catalog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 实战 45 讲&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="DB" scheme="chunlife.top/categories/DB/"/>
    
    
    <category term="MySQL" scheme="chunlife.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>go-kratos写代码浅记</title>
    <link href="chunlife.top/2022/06/16/go-kratos%E5%86%99%E4%BB%A3%E7%A0%81%E6%B5%85%E8%AE%B0/"/>
    <id>chunlife.top/2022/06/16/go-kratos%E5%86%99%E4%BB%A3%E7%A0%81%E6%B5%85%E8%AE%B0/</id>
    <published>2022-06-16T08:08:08.000Z</published>
    <updated>2023-04-01T09:49:00.994Z</updated>
    
    <content type="html"><![CDATA[<p>使用Kratos进行代码的开发，对一些简单功能进行简单的记录。</p><a id="more"></a><h3><span id="jwt验证">JWT验证</span></h3><p>拦截中间件以及验证JWT Token，过滤掉不验证的URL。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWhiteListMatcher</span><span class="params">()</span> <span class="title">selector</span>.<span class="title">MatchFunc</span></span> &#123;</span><br><span class="line">whiteList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">whiteList[<span class="string">"/xxx.v1.xxxxService/Login"</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, operation <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := whiteList[operation]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.Middleware(</span><br><span class="line">    selector.Server(</span><br><span class="line">        recovery.Recovery(),</span><br><span class="line">ratelimit.Server(),</span><br><span class="line">        jwt.Server(</span><br><span class="line">            <span class="function"><span class="keyword">func</span><span class="params">(token *jwt4.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="keyword">byte</span>(auth.ApiKey), <span class="literal">nil</span></span><br><span class="line">            &#125;,</span><br><span class="line">            jwt.WithSigningMethod(jwt4.SigningMethodHS256), <span class="comment">// 设置加密算法</span></span><br><span class="line">            jwt.WithClaims(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">jwt4</span>.<span class="title">Claims</span></span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;jwt4.MapClaims&#123;&#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        ),</span><br><span class="line">        jwtverify.Server(c),</span><br><span class="line">    ).Match(NewWhiteListMatcher()).Build(),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="comment">// jwtverify.Server(c) 用来拦截解析出来的jwt，以作验证</span></span><br><span class="line"><span class="keyword">type</span> JwtUser <span class="keyword">struct</span> &#123;</span><br><span class="line">UID <span class="keyword">int64</span> <span class="string">`json:"uid"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Server</span><span class="params">(config *conf.Server)</span> <span class="title">middleware</span>.<span class="title">Middleware</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(handler middleware.Handler)</span> <span class="title">middleware</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">user := JwtUser&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> claims, ok := jwt.FromContext(ctx); ok &#123;</span><br><span class="line">arr, _ := json.Marshal(claims)</span><br><span class="line">json.Unmarshal(arr, &amp;user)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> user.UID == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Unauthorized(<span class="string">""</span>, <span class="string">"jwt get user failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure><p>Login生成token：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generate token</span></span><br><span class="line">claims := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims&#123;</span><br><span class="line">    <span class="string">"uid"</span>: user.Id,</span><br><span class="line">    <span class="string">"exp"</span>: time.Now().Unix() + <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>,</span><br><span class="line">&#125;)</span><br><span class="line">token, err := claims.SignedString([]<span class="keyword">byte</span>(uc.key))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的token，前端放在<code>Header</code>的<code>Authorization</code>中。经过<code>jwt</code>中间件的解析，然后再经过我们写的中间件加上我们自己的验证方式，例如验证参数逻辑。</p><h3><span id="中间件的执行顺序">中间件的执行顺序</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">http.Middleware(</span><br><span class="line">middleware,</span><br><span class="line">middleware2,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloHandler</span><span class="params">(ctx http.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">......</span><br><span class="line">    </span><br><span class="line">http.SetOperation(ctx, <span class="string">"/helloworld.Greeter/SayHello"</span>)</span><br><span class="line">h := ctx.Middleware(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">fmt.Println(<span class="string">"sayHelloHandler in"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;helloworld.HelloReply&#123;Message: req.(*helloworld.HelloRequest).Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">err := ctx.Returns(h(ctx, &amp;in))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"sayHelloHandler out"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//middleware in</span></span><br><span class="line"><span class="comment">//middleware 2 in</span></span><br><span class="line"><span class="comment">//sayHelloHandler in </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//middleware 2 out</span></span><br><span class="line"><span class="comment">//middleware out</span></span><br><span class="line"><span class="comment">//sayHelloHandler out</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数不使用上述格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uploadFile</span><span class="params">(ctx http.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"service uploadFile in"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用此格式，将无法使用http.Middleware中间件，因为其没有调用ctx.Middleware，也就没法链接插件。</span></span><br><span class="line"><span class="comment">// 同理，其他HTTP框架如gin，echo等均需满足此格式。</span></span><br></pre></td></tr></table></figure><p>综上，我们自己写的代码要使用<code>Server Middleware</code>，需要按照上面的格式进行编写。</p><p>另外还有很多插件形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">httpSrv := http.NewServer(</span><br><span class="line">    http.Address(<span class="string">":8001"</span>),</span><br><span class="line">    http.Middleware(</span><br><span class="line">        <span class="comment">// add service filter</span></span><br><span class="line">        serviceMiddleware,</span><br><span class="line">        serviceMiddleware2,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// add global filter</span></span><br><span class="line">    http.Filter(globalFilter, globalFilter2),</span><br><span class="line">)</span><br><span class="line"><span class="comment">// register http hanlder to http server</span></span><br><span class="line">helloworld.RegisterGreeterHTTPServer(httpSrv, s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// add route filter</span></span><br><span class="line">r := httpSrv.Route(<span class="string">"/"</span>, routeFilter, routeFilter2)</span><br><span class="line"><span class="comment">// add path filter to custom route</span></span><br><span class="line">r.GET(<span class="string">"/hello/&#123;name&#125;"</span>, sayHelloHandler, pathFilter, pathFilter2)</span><br></pre></td></tr></table></figure><p>执行顺序为：<code>globalFilter(http)</code> --&gt; <code>routeFilter(http)</code> --&gt; <code>pathFilter(http)</code> --&gt; <code>serviceFilter(service)</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Kratos进行代码的开发，对一些简单功能进行简单的记录。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="http" scheme="chunlife.top/tags/http/"/>
    
    <category term="go-kratos" scheme="chunlife.top/tags/go-kratos/"/>
    
  </entry>
  
  <entry>
    <title>proto管理之submodule</title>
    <link href="chunlife.top/2022/05/09/proto%E7%AE%A1%E7%90%86%E4%B9%8Bsubmodule/"/>
    <id>chunlife.top/2022/05/09/proto%E7%AE%A1%E7%90%86%E4%B9%8Bsubmodule/</id>
    <published>2022-05-09T09:02:40.000Z</published>
    <updated>2023-02-25T10:49:35.523Z</updated>
    
    <content type="html"><![CDATA[<p>使用Git Submodule方式管理proto文件，各项目直接依赖IDL文件本身，依赖源头均来自git子仓，保证依赖源的唯一性。对齐各服务间的proto文件版本。</p><p>依赖问题引发的问题是很多的，对于依赖的管理也会出现很多，例如：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Dependency_hell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dependency_hell</a></p><p><a href="https://zh.m.wikipedia.org/zh-hans/%E7%9B%B8%E4%BE%9D%E6%80%A7%E5%9C%B0%E7%8B%B1" target="_blank" rel="noopener">https://zh.m.wikipedia.org/zh-hans/%E7%9B%B8%E4%BE%9D%E6%80%A7%E5%9C%B0%E7%8B%B1</a></p></blockquote><h2><span id="子仓目录">子仓目录</span></h2><p>参考Google家的库<a href="https://github.com/googleapis/googleapis" target="_blank" rel="noopener">googleapis</a>：</p><table><thead><tr><th>目录</th><th>举栗</th></tr></thead><tbody><tr><td>总目录（子仓）</td><td>xxxxxapis</td></tr><tr><td>项目名</td><td>cloud / ads / monitor</td></tr><tr><td>模块名</td><td>device / datacatalog / user</td></tr><tr><td>版本</td><td>v1 /  v2  /  v3</td></tr><tr><td>文件</td><td>service.proto、error.proto</td></tr></tbody></table><blockquote><p>子仓不保存IDL文件生成的中间文件，只保存原始文件。</p></blockquote><h2><span id="项目引入">项目引入</span></h2><ul><li>引入子仓</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://xxxx.com/xxxx/myapis</span><br></pre></td></tr></table></figure><p>子仓在引入后，不去更新，子仓会呈现固定的版本。</p><img src="image-20220510094907212.png" alt="目录结构" style="zoom: 80%;"><p>更新子仓，合并上游版本变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 进入子仓内，运行命令</span><br><span class="line">$ git fetch</span><br><span class="line">$ git merge origin/master</span><br><span class="line"></span><br><span class="line">// 也可以在主仓中，运行命令</span><br><span class="line">$ git submodule update --remote myapis</span><br></pre></td></tr></table></figure><p>更多关于子仓的操作命令，参考：<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git-工具-子模块</a>，也可参考下图。</p><p>脑图分享链接：<a href="https://naotu.baidu.com/file/df1c4f51d9617121e17b31ba6e577d3a?token=280c1c34c3b920e4" target="_blank" rel="noopener">https://naotu.baidu.com/file/df1c4f51d9617121e17b31ba6e577d3a?token=280c1c34c3b920e4</a></p><img src="Git-Sub子仓.png" alt="Git-Sub子仓" style="zoom:80%;"><h2><span id="proto文件">proto文件</span></h2><p>proto文件中，<code>package</code>、<code>option go_package</code>，这两个参数是我们需要注意的：</p><p><code>package</code>：即别的proto文件在引用该文件后，其使用的索引前缀。</p><p><code>option go_package</code>： protoc 编译时，生成的路径地址，可以用go_out设置生成的路径，使用<code>source_relative</code>让文件生成在相对路径中。</p><p>proto文件语法以及版本追踪工具：</p><ul><li><p><a href="https://github.com/bufbuild/buf" target="_blank" rel="noopener">buf</a> 推荐</p></li><li><p><a href="https://github.com/nilslice/protolock" target="_blank" rel="noopener">protolock</a></p></li><li><p><a href="https://github.com/googleapis/api-linter" target="_blank" rel="noopener">api-linter</a></p></li></ul><h2><span id="编译">编译</span></h2><p>由于依赖原始文件，在拉取到子仓后，或是更新到最新子仓后，proto文件都应是再次编译，故在<code>Makefile</code>中，<code>build</code>命令中，需要加入重新编译proto文件的操作，让proto文件每次都保持最新状态，防止中间版本的出现。</p><blockquote><p>也可以使用例如<em>BAZEL</em>编译，声名依赖，指定proto文件。</p></blockquote><h2><span id="实践例子">实践例子</span></h2><p>案例：<a href="https://github.com/younglifestyle/kratos-layout" target="_blank" rel="noopener">kratos-layout</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用Git Submodule方式管理proto文件，各项目直接依赖IDL文件本身，依赖源头均来自git子仓，保证依赖源的唯一性。对齐各服务间的proto文件版本。&lt;/p&gt;
&lt;p&gt;依赖问题引发的问题是很多的，对于依赖的管理也会出现很多，例如：&lt;/p&gt;
&lt;blockquote</summary>
      
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="Protobuff" scheme="chunlife.top/tags/Protobuff/"/>
    
    <category term="submodule" scheme="chunlife.top/tags/submodule/"/>
    
  </entry>
  
  <entry>
    <title>go-kratos HTTP方法支持以及FieldMask的使用简介</title>
    <link href="chunlife.top/2022/05/06/go-kratos-HTTP%E6%96%B9%E6%B3%95%E6%94%AF%E6%8C%81%E4%BB%A5%E5%8F%8AFieldMask%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>chunlife.top/2022/05/06/go-kratos-HTTP%E6%96%B9%E6%B3%95%E6%94%AF%E6%8C%81%E4%BB%A5%E5%8F%8AFieldMask%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2022-05-06T08:49:03.000Z</published>
    <updated>2023-02-25T10:49:35.507Z</updated>
    
    <content type="html"><![CDATA[<p>kratos 的proto http 插件——<code>protoc-gen-go-http</code>，对body以及query参数只能选择其一支持，不论其<code>Method</code>为何种。query、vars支持同时存在。</p><p>源码可查：<code>go-kratos/kratos/cmd/protoc-gen-go-http/template.go</code>。</p><p>和<a href="https://cloud.google.com/apis/design/standard_methods?hl=zh-cn#create" target="_blank" rel="noopener">Google API 设计指南</a>上对方法的设计有点不一样。</p><table><thead><tr><th></th><th>GET</th><th>POST</th><th>PUT</th><th>DELETE</th></tr></thead><tbody><tr><td>query (/hello?x=s)</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>vars (/hello/{name})</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>body</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>body与query同时存在：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">service Auth &#123;</span><br><span class="line">    rpc Register (RegisterReq) returns (RegisterReply) &#123;</span><br><span class="line">        option (google.api.http) = &#123;</span><br><span class="line">            post: &quot;/api/v1/mdm/register&quot;</span><br><span class="line">            body: &quot;user_info&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterReq &#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    string password = 2;</span><br><span class="line">    message UserInfo &#123;</span><br><span class="line">        string info = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    UserInfo user_info = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message RegisterReply &#123;</span><br><span class="line">    int64 id = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="header中解析数据">Header中解析数据</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// client发上来的header保存在此处</span><br><span class="line">transport.FromClientContext(ctx)</span><br><span class="line"></span><br><span class="line">transport.FromServerContext(ctx)</span><br><span class="line"></span><br><span class="line">和&quot;google.golang.org/grpc/metadata&quot;中的函数同：</span><br><span class="line">FromIncomingContext、FromOutgoingContext</span><br></pre></td></tr></table></figure><h3><span id="请求中的参数解析">请求中的参数解析</span></h3><p>从test文件的示例可以看出，<code>github.com/go-kratos/kratos/encoding/form/form_test.go</code>，解析URL中的嵌套数据的方法：</p><h4><span id="嵌套参数">嵌套参数</span></h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  message test &#123;</span><br><span class="line">    string one = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  test ones = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>URL Query：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000/helloworld?ones.one=1234</span><br></pre></td></tr></table></figure><h4><span id="数组参数">数组参数</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Simples: []string&#123;&quot;3344&quot;, &quot;5566&quot;&#125;</span><br><span class="line"></span><br><span class="line">simples=3344&amp;simples=5566</span><br></pre></td></tr></table></figure><h4><span id="fieldmask参数">FieldMask参数</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field:     &amp;fieldmaskpb.FieldMask&#123;Paths: []string&#123;&quot;1&quot;, &quot;2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">field=1,2</span><br></pre></td></tr></table></figure><p><code>FieldMask</code>借助库：</p><p><a href="https://github.com/mennanov/fmutils" target="_blank" rel="noopener">https://github.com/mennanov/fmutils</a></p><p><a href="https://github.com/mennanov/fieldmask-utils" target="_blank" rel="noopener">https://github.com/mennanov/fieldmask-utils</a></p><p>不过当前Kratos对query中的<code>fieldmask</code>会进行大写转换，导致其字段无法进行有效的<code>Filter</code>。我提了一个<a href="https://github.com/go-kratos/kratos/issues/1969" target="_blank" rel="noopener">issue</a>。</p><p>fieldmask_utils是对字段名进行匹配，而不是tag名，而Kratos则会将Me ——&gt; _me，而其字段为<code>Me</code>，那库则无法将其正常过滤，正常GRPC协议不会出现此转换，此转换应该是Kratos HTTP decode request时发生的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fieldmask_utils <span class="string">"github.com/mennanov/fieldmask-utils"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对fieldmask做一下中间拦截，也可以直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">naming</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">"foo"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Foo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> request UpdateUserRequest</span><br><span class="line">userDst := &amp;testproto.User&#123;&#125; <span class="comment">// a struct to copy to</span></span><br><span class="line">mask, _ := fieldmask_utils.MaskFromPaths(request.FieldMask.Paths, naming)</span><br><span class="line">fieldmask_utils.StructToStruct(mask, request.User, userDst)</span><br><span class="line"><span class="comment">// Only the fields mentioned in the field mask will be copied to userDst, other fields are left intact</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FieldMask</code>用在response、request参数限制返回，以及指定参数的更新上。</p><p><a href="https://mp.weixin.qq.com/s/L7He7M4JWi84z1emuokjbQ" target="_blank" rel="noopener">Netflix API 设计实践: 使用FieldMask</a></p><p>request中指定paths，response根据paths mask参数，返回需要的字段。</p><p><a href="https://mp.weixin.qq.com/s/uRuejsJN37hdnCN4LLeBKQ" target="_blank" rel="noopener">Netflix API 设计实践(二): 使用FieldMask进行数据变更</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message UpdateProductionRequest &#123;</span><br><span class="line">  ProductionUpdateOperation update = 1;</span><br><span class="line">  google.protobuf.FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;update&quot;: &#123;</span><br><span class="line">&quot;format&quot;: &quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;update_mask&quot;: [</span><br><span class="line">&quot;format&quot;, </span><br><span class="line">&quot;schedule.planned_launch_date&quot;,</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新操作就会执行更新<code>format</code>，<code>schedule.planned_launch_date</code>两个字段，由于后者没有传值，变相的也就是将此字段置空。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;kratos 的proto http 插件——&lt;code&gt;protoc-gen-go-http&lt;/code&gt;，对body以及query参数只能选择其一支持，不论其&lt;code&gt;Method&lt;/code&gt;为何种。query、vars支持同时存在。&lt;/p&gt;
&lt;p&gt;源码可查：&lt;co</summary>
      
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="go-kratos" scheme="chunlife.top/tags/go-kratos/"/>
    
    <category term="fieldmask" scheme="chunlife.top/tags/fieldmask/"/>
    
    <category term="Protobuff" scheme="chunlife.top/tags/Protobuff/"/>
    
  </entry>
  
  <entry>
    <title>Meituan-Leaf Golang实现</title>
    <link href="chunlife.top/2022/05/04/Meituan-Leaf-Golang%E5%AE%9E%E7%8E%B0/"/>
    <id>chunlife.top/2022/05/04/Meituan-Leaf-Golang%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-04T04:44:14.000Z</published>
    <updated>2023-02-25T10:49:35.461Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分由于内部技术栈的问题，需要统一，同时，需要有更多的改造，接入公司内部RPC，导入一致的服务治理等需求，所以需要一个Go版本的发号器，搜了网上很多版本，发现并没有<code>Leaf</code>的替代版本，而Leaf的实现细节有很多文章都分析过了，这样看起来移植一下也不困难了。</p><p>美团Leaf的技术细节在官方文档中介绍的很详细，这里参考其技术实现细节<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a>。</p><h3><span id="遇到的问题">遇到的问题</span></h3><h4><span id="号段模式">号段模式</span></h4><p>在号段模式时，碰到的问题主要有两个：</p><ul><li>锁竞的问题</li><li>context传递的问题</li></ul><p>锁竞争的问题是在请求中使用锁，但我在最初的版本中，当并发比较大时，就会出现死锁的问题。后面使用闭包+<code>defer</code>解决了此问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    cacheSegmentBuffer.RLock()</span><br><span class="line">    <span class="keyword">defer</span> cacheSegmentBuffer.RUnLock()</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;(); value != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context传递的问题，这个其实在<code>gin</code>中就碰到过，在handler中开协程出去，若是将handler中的context传递过去，这里面就会出问题，因为handler中的context在handler主体执行完后，会执行context的cancel（若该上下文其为timeout context），也就会导致协程若是用到了这个上下文也会被cancel。</p><p>所以这里我改为在传递的时候传入<code>context.TODO()</code>。</p><h4><span id="雪花算法">雪花算法</span></h4><p>这里面遇到的问题，就是在创建实例节点的时候，没有自增序号的问题，我这里借助<code>etcd</code>的迷你事务<code>TXN</code>，通过乐观锁形式的创建方式，去创建<code>key</code>，这样来防止创建重复的键值。</p><h3><span id="输出">输出</span></h3><p><a href="https://github.com/younglifestyle/seg-server" target="_blank" rel="noopener">https://github.com/younglifestyle/seg-server</a></p><h3><span id="参考">参考</span></h3><p><a href="https://blog.csdn.net/bskfnvjtlyzmv867/article/details/90175306" target="_blank" rel="noopener">美团Leaf源码——号段模式源码解析</a></p><p><a href="https://blog.csdn.net/bskfnvjtlyzmv867/article/details/90247036?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165120147516782184621735%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165120147516782184621735&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-90247036.nonecase&amp;utm_term=leaf&amp;spm=1018.2226.3001.4450" target="_blank" rel="noopener">美团Leaf源码——snowflake模式源码解析</a></p><p><a href="https://blog.51cto.com/u_12497420/3357165" target="_blank" rel="noopener">美团Leaf snowflake模式详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一部分由于内部技术栈的问题，需要统一，同时，需要有更多的改造，接入公司内部RPC，导入一致的服务治理等需求，所以需要一个Go版本的发号器，搜了网上很多版本，发现并没有&lt;code&gt;Leaf&lt;/code&gt;的替代版本，而Leaf的实现细节有很多文章都分析过了，这样看起来移植一下</summary>
      
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="Go" scheme="chunlife.top/tags/Go/"/>
    
    <category term="Leaf" scheme="chunlife.top/tags/Leaf/"/>
    
  </entry>
  
  <entry>
    <title>服务器文件分片合并下载</title>
    <link href="chunlife.top/2022/05/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E5%90%88%E5%B9%B6%E4%B8%8B%E8%BD%BD/"/>
    <id>chunlife.top/2022/05/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E5%90%88%E5%B9%B6%E4%B8%8B%E8%BD%BD/</id>
    <published>2022-05-04T04:40:35.115Z</published>
    <updated>2022-05-04T04:40:35.115Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个文件服务器，文件就分为大文件和小文件，小文件嘛，好处理，毕竟不大，主要关注的点就是，细碎，需要集中管理，比如将其塞到一个文件中合并存储，当然，这玩意不是我现在关注的点。这里关注的是大文件的操作。</p><a id="more"></a><p>以下大多文字信息均来自：<a href="https://segmentfault.com/a/1190000000725971" target="_blank" rel="noopener">服务器端文件分片合并的思考和实践</a></p><h2><span id="大文件的需求">大文件的需求</span></h2><p>文件上传是个很常见的需求。尽管<code>HTTP</code>是基于<code>TCP</code>上层的协议，但是HTTP协议本身并不适合处理超大的请求体，文件上传有很大的稳定性问题，如果中途断开了，将前功尽弃。为了改善用户体验或者缓解服务器压力，通常会考虑将文件分成小片，将小片一个个上传，如果中途断开了也能从某个失败的小片开始继续上传。</p><p>在前端的处理上，对于Web页面，可以采用<a href="http://www.plupload.com/" target="_blank" rel="noopener">plupload</a>作为上传组件，该组件支持html5、flash、sl等多种上传方式，因此，可以提供较好的浏览器兼容性。七牛云存储的<a href="https://github.com/qiniupd/qiniu-js-sdk/" target="_blank" rel="noopener">js-sdk</a>就是基于这个组件开发的。不过本文的重点并不是讨论前端技术，关于前端就到此为止。</p><hr><h2><span id="文件下载">文件下载</span></h2><p>大文件上传时普遍都采取分片的方式进行上传，那服务器接收的分片也会有一个整合的过程，当然，博客里也提到一些整合的方式介绍，我这里是比较中意其说的不合并的方式，有几个原因：</p><p>一、合并占用IO操作，消耗性能和时间；</p><p>二、文件分片有利于数据加密；</p><p>这是我想的两点，所以，我并没有使得文件合并这个操作出现在我的服务中，我参考了博客中说的一个操作，HTTP流。</p><blockquote><h4><span id="为什么非要合并">为什么非要合并!</span></h4><p>再思考下去，如果文件系统无法做到将分片直接连接起来的的话，那么从用户接口层(HTTP)是否能做到呢？试想，<strong>通过HTTP的方式提供文件的访问，如果HTTP服务器能够知道这个文件是由多个小文件按何种顺序组成的，那么就可以按照顺序将分片依次放在同一个HTTP流中返回，对用户来说一次请求还是得到一个文件，好像文件是合并好的一样，但实际上文件在文件系统并不存在。</strong></p><p>这样做需要单独将分片的顺序维护好，每次都要读出分片的顺序和位置，然后依次一个个写入HTTP流中。但是高层的Web编程框架似乎无法支持这种做法。</p></blockquote><h2><span id="代码">代码</span></h2><p>这里的代码要修改HTTP库中的http.serveFile函数。</p><p><code>serveContent</code>函数我砍掉了一些操作，比如支持HTTP的Range，针对于实际的业务场景，客户端断点续传，多线程下载那肯定是要支持的，我这里是处于简化，直接砍掉了这个操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeMyFile</span><span class="params">(w http.ResponseWriter, r *http.Request, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">dir, baseName := filepath.Split(name)</span><br><span class="line">serveFile(w, r, http.Dir(dir), baseName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toHTTPError</span><span class="params">(err error)</span> <span class="params">(msg <span class="keyword">string</span>, httpStatus <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"404 page not found"</span>, http.StatusNotFound</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"403 Forbidden"</span>, http.StatusForbidden</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Default:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"500 Internal Server Error"</span>, http.StatusInternalServerError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name is '/'-separated, not filepath.Separator.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveFile</span><span class="params">(w http.ResponseWriter, r *http.Request, fs http.FileSystem, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">f, err := fs.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">msg, code := toHTTPError(err)</span><br><span class="line">http.Error(w, msg, code)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">d, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">msg, code := toHTTPError(err)</span><br><span class="line">http.Error(w, msg, code)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buffer := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>))</span><br><span class="line">bw := bufio.NewWriter(buffer)</span><br><span class="line"><span class="keyword">var</span> size <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// serveContent will check modification time</span></span><br><span class="line">sizeFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123; <span class="keyword">return</span> size, <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d.IsDir() &#123;</span><br><span class="line"><span class="comment">//dir := fs.(http.Dir)</span></span><br><span class="line"></span><br><span class="line">dirs, err := f.Readdir(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">"Error reading directory"</span>, http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a, b, c ..., 保存文件的时候即以字母做顺序标记了，根据个人修改</span></span><br><span class="line">sort.Slice(dirs, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> dirs[i].Name() &lt; dirs[j].Name() &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, ff := <span class="keyword">range</span> dirs &#123;</span><br><span class="line"><span class="keyword">if</span> !ff.IsDir() &#123;</span><br><span class="line"><span class="comment">// 以Dir为相对路径，接上ff.Name()，也就是[Dir/name]</span></span><br><span class="line">fi, err := fs.Open(path.Join(name, ff.Name()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">msg, code := toHTTPError(err)</span><br><span class="line">http.Error(w, msg, code)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io.Copy(bw, fi)</span><br><span class="line">size += ff.Size()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serveContent(w, r, d.Name(), d.ModTime(), sizeFunc, bytes.NewReader(buffer.Bytes()))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">size = d.Size()</span><br><span class="line"></span><br><span class="line">serveContent(w, r, d.Name(), d.ModTime(), sizeFunc, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unixEpochTime = time.Unix(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// isZeroTime reports whether t is obviously unspecified (either zero or Unix()=0).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isZeroTime</span><span class="params">(t time.Time)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.IsZero() || t.Equal(unixEpochTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setLastModified</span><span class="params">(w http.ResponseWriter, modtime time.Time)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !isZeroTime(modtime) &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Last-Modified"</span>, modtime.UTC().Format(http.TimeFormat))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveContent</span><span class="params">(w http.ResponseWriter, r *http.Request, name <span class="keyword">string</span>, modtime time.Time, sizeFunc <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">int64</span>, error)</span>, <span class="title">content</span> <span class="title">io</span>.<span class="title">ReadSeeker</span>)</span> &#123;</span><br><span class="line">setLastModified(w, modtime)</span><br><span class="line"></span><br><span class="line">size, err := sizeFunc()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendSize := size</span><br><span class="line"><span class="keyword">var</span> sendContent io.Reader = content</span><br><span class="line"><span class="keyword">if</span> size &gt;= <span class="number">0</span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Accept-Ranges"</span>, <span class="string">"bytes"</span>)</span><br><span class="line"><span class="keyword">if</span> w.Header().Get(<span class="string">"Content-Encoding"</span>) == <span class="string">""</span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Content-Length"</span>, strconv.FormatInt(sendSize, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line"><span class="keyword">if</span> r.Method != <span class="string">"HEAD"</span> &#123;</span><br><span class="line">io.CopyN(w, sendContent, sendSize)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个文件服务器，文件就分为大文件和小文件，小文件嘛，好处理，毕竟不大，主要关注的点就是，细碎，需要集中管理，比如将其塞到一个文件中合并存储，当然，这玩意不是我现在关注的点。这里关注的是大文件的操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Go" scheme="chunlife.top/tags/Go/"/>
    
    <category term="服务器下载" scheme="chunlife.top/tags/服务器下载/"/>
    
    <category term="分片合并" scheme="chunlife.top/tags/分片合并/"/>
    
  </entry>
  
  <entry>
    <title>服务治理——监控</title>
    <link href="chunlife.top/2022/04/06/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E7%9B%91%E6%8E%A7/"/>
    <id>chunlife.top/2022/04/06/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E7%9B%91%E6%8E%A7/</id>
    <published>2022-04-06T09:35:56.000Z</published>
    <updated>2022-05-04T04:40:35.115Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将演示如何简单的搭建起整个监控平台。当前服务主要使用语言为Go，所以下面均用Go作为后端服务。</p><p>看下服务治理的大概定义：</p><blockquote><p><strong>1、服务注册与发现。</strong></p><p><strong>2、可观测性。</strong></p><p><strong>3、流量管理。</strong></p><p><strong>4、安全。</strong></p><p><strong>5、控制。</strong></p><p><a href="https://www.zhihu.com/question/56125281/answer/1099439237" target="_blank" rel="noopener">https://www.zhihu.com/question/56125281/answer/1099439237</a></p></blockquote><p>那监控就属于服务治理中的<code>可观测性</code>——常见的包括监控（Metrics）、日志（Logging）、调用追踪（Trace）。而本篇则是着重讲述监控这一点。</p><p>服务在运行时，会产生很多数据指标（CPU、内存占用，QPS等），而这些数据的产生则可由服务本身记录，例如发送一个HTTP请求，就加<code>1</code>，与逻辑无关，却又是与数据相关的搜集代码就是埋点操作。普通服务状态下，我们使用微服务框架去封装以及分层这一步操作。</p><h2><span id="框架">框架</span></h2><p>对常见协议的Metrics收集，HTTP/GRPC。</p><p>目前业务上使用的是<a href="https://github.com/asim/go-micro" target="_blank" rel="noopener">Go-Micro</a>，不过Go-Micro没写HTTP的指标收集，这个比较简单，需要自己添加一下，使用gin自带的也可以。</p><p><a href="https://github.com/go-kratos/kratos" target="_blank" rel="noopener">Kratos</a>和<a href="https://github.com/zeromicro/go-zero" target="_blank" rel="noopener">go-zero</a>都自带了，比较省心。</p><h2><span id="服务组件">服务组件</span></h2><p>使用docker-compose将服务一次性全部启动。</p><p><a href="https://github.com/Einsteinish/Docker-Compose-Prometheus-and-Grafana/blob/master/docker-compose.yml" target="_blank" rel="noopener">地址</a></p><p>在<code>docker-compose.yml</code>中加入，钉钉通知插件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#钉钉插件</span></span><br><span class="line">  webhook:</span><br><span class="line">    image: timonwong/prometheus-webhook-dingtalk:v1.<span class="number">4.0</span></span><br><span class="line">    restart: <span class="string">"always"</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">8060</span>:<span class="number">8060</span></span><br><span class="line">    container_name: <span class="string">"dingtalk"</span>           </span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime:ro</span><br><span class="line">    command:</span><br><span class="line">      - <span class="string">'--ding.profile=webhook1=https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxxxx'</span> <span class="comment">#token指定钉钉</span></span><br><span class="line">    networks:</span><br><span class="line">      - monitor-net</span><br></pre></td></tr></table></figure><blockquote><p>Token从钉钉群里的自定义机器人中获取</p><p>另外注意，dingtalk组件版本为v1.4.0，v2版本后此启动方式将报错。V2版本<a href="https://github.com/timonwong/prometheus-webhook-dingtalk/issues/167#issuecomment-964741026" target="_blank" rel="noopener">使用</a>。</p><p>‘config.yml’ does not exist, try --help</p></blockquote><p><code>alertmanager/config.yml</code>修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="attr">    receiver:</span> <span class="string">'webhook'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">'webhook'</span></span><br><span class="line"><span class="attr">      webhook_configs:</span></span><br><span class="line"><span class="attr">          - send_resolved:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">            url:</span> <span class="string">'http://dingtalk:8060/dingtalk/webhook1/send'</span></span><br></pre></td></tr></table></figure><p><code>prometheus</code>的配置文件中，指定了<code>alertmanager</code>的地址，以及报警规则的文件位置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load and evaluate rules in this file every 'evaluation_interval' seconds.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"alert.rules"</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line"><span class="attr">  - scheme:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'alertmanager:9093'</span></span><br></pre></td></tr></table></figure><p><code>alert.rules</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">targets</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">monitor_service_down</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    for:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"监控报警 - Monitor service non-operational"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"Service <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> is down."</span></span><br></pre></td></tr></table></figure><p><code>grafana</code>需要饼图插件的话，可以下命令获取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> https://grafana.com/grafana/plugins/grafana-piechart-panel/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it -u root grafana grafana-cli plug</span></span><br><span class="line">ins install grafana-piechart-panel</span><br></pre></td></tr></table></figure><h2><span id="结果">结果</span></h2><h3><span id="展示">展示</span></h3><img src="image-20220406201110956.png" alt="Kratos监控" style="zoom: 33%;"><h3><span id="报警">报警</span></h3><img src="image-20220406201208499.png" alt="报警示例" style="zoom: 80%;"><h2><span id="资料">资料</span></h2><p>prometheus服务自发现，不需要手动去修改文件，指定prometheus的监控程序。</p><p><a href="https://prometheus.io/blog/2018/07/05/implementing-custom-sd/" target="_blank" rel="noopener">https://prometheus.io/blog/2018/07/05/implementing-custom-sd/</a></p><p><a href="https://github.com/KatePang13/prometheus_docs/blob/main/content/blog/2015-08-17-service-discovery-with-etcd.md" target="_blank" rel="noopener">https://github.com/KatePang13/prometheus_docs/blob/main/content/blog/2015-08-17-service-discovery-with-etcd.md</a></p><p>prometheus服务发现实现：<a href="https://github.com/fabxc/prom_sd_example" target="_blank" rel="noopener">https://github.com/fabxc/prom_sd_example</a></p><p>promQL的语法：<a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language" target="_blank" rel="noopener">https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language</a></p><p>非常全的对prometheus各组件采集的文档：<a href="https://erdong.site/prometheus-notes/" target="_blank" rel="noopener">https://erdong.site/prometheus-notes/</a></p><p><a href="https://mp.weixin.qq.com/s/OVYb6VkTCN2QhfODy49_uA" target="_blank" rel="noopener">Prometheus 生产部署案例</a></p><p><a href="https://github.com/flaviostutz/promster" target="_blank" rel="noopener">多层级数据指标收集</a></p><hr><p>P95、P90的值都比较重要，是查看接口性能的一个重要指标。</p><p><a href="https://www.cnblogs.com/hunternet/p/14354983.html" target="_blank" rel="noopener">P95，P90值的含义</a></p><p><a href="https://stackoverflow.com/questions/64610285/prometheus-latency-graph-in-histogram-and-calculate-percentile" target="_blank" rel="noopener">计算95线</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇将演示如何简单的搭建起整个监控平台。当前服务主要使用语言为Go，所以下面均用Go作为后端服务。&lt;/p&gt;
&lt;p&gt;看下服务治理的大概定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、服务注册与发现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、可观</summary>
      
    
    
    
    <category term="分布式服务" scheme="chunlife.top/categories/分布式服务/"/>
    
    
    <category term="monitor" scheme="chunlife.top/tags/monitor/"/>
    
    <category term="prometheus" scheme="chunlife.top/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>docker基础命令以及多阶段编译</title>
    <link href="chunlife.top/2022/03/28/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A4%9A%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91/"/>
    <id>chunlife.top/2022/03/28/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A4%9A%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91/</id>
    <published>2022-03-28T13:31:53.000Z</published>
    <updated>2022-05-04T04:40:35.089Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下docker的基础命令，以及多阶段编译的简单应用。</p><h2><span id="基础命令">基础命令</span></h2><ul><li>FROM</li></ul><p>拉取一个基准环境镜像</p><ul><li>RUN</li></ul><p>运行指令</p><ul><li>COPY</li></ul><p>将宿主机的目录复制到镜像中，注意目录路径</p><ul><li>WORKDIR</li></ul><p>改变在容器的当前目录</p><ul><li>EXPOSE</li></ul><p>表示容器会暴露此端口，但不是真正的在运行时暴露这个端口，只是一个类似于文档的作用，真正的暴露还是在docker -p 8000:8000，这样做一个端口的映射</p><ul><li>ENTRYPOINT</li></ul><p>类似的是CMD命令，ENTRYPOINT 是容器启动时执行的不变的命令，CMD是可以被用户修改的参数。</p><p>ENTRYPOINT [ “echo”, “a” ]</p><p>CMD [ “b” ]</p><p>执行结果： a, b</p><p>Docker run -p 8000:8000 imageName c d e</p><p>执行结果：a c d e ( ENTRYPOINT 正常情况下不会被覆盖，CMD是提供个默认值，可被重写 )</p><h2><span id="构建">构建</span></h2><p>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/learn-docker</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── hello</span><br><span class="line">    └── main.go</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">"hello world!!!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_ = r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动编译环境</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.17</span>-alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置编译环境</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go env -w GO111MODULE=on</span></span><br><span class="line"><span class="bash">RUN go env -w GOPROXY=https://goproxy.cn,direct</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 拷贝源代码到镜像中</span></span></span><br><span class="line"><span class="bash">COPY . /go/src/learn-docker</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 编译</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 进入代码目录</span></span></span><br><span class="line"><span class="bash">WORKDIR /go/src/learn-docker</span></span><br><span class="line"><span class="bash"><span class="comment"># 微服务中，编译指定的项目即可，不建议编译整个大型项目，浪费时间，同时也容易构建失败</span></span></span><br><span class="line"><span class="bash">RUN go install ./hello/...</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM alpine:3.15</span></span><br><span class="line"><span class="bash">COPY --from=builder /go/bin/hello /bin/hello</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 申明暴露的端口</span></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 设置服务入口</span></span></span><br><span class="line"><span class="bash">ENTRYPOINT [ <span class="string">"/bin/hello"</span> ]</span></span><br></pre></td></tr></table></figure><blockquote><p>命令执行的顺序会影响构建速度，不变的命令应在之前运行，变化的放在后面，不变的会尽量用到cache。</p></blockquote><p>构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t hello -f Dockerfile .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY                     TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">hello                          latest    530fe26c543a   31 minutes ago   14.7MB</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理一下docker的基础命令，以及多阶段编译的简单应用。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;基础命令&quot;&gt;基础命令&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FROM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拉取一个基准环境镜像&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RUN&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="devops" scheme="chunlife.top/categories/devops/"/>
    
    
    <category term="docker" scheme="chunlife.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>网络第二序章—传输层</title>
    <link href="chunlife.top/2022/03/22/%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E5%BA%8F%E7%AB%A0%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>chunlife.top/2022/03/22/%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E5%BA%8F%E7%AB%A0%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2022-03-22T10:15:44.000Z</published>
    <updated>2022-05-04T04:40:35.123Z</updated>
    
    <content type="html"><![CDATA[<p>传输层：UDP和TCP。</p><p>这俩协议真是有太多说的了，毕竟网络里头，TCP/IP协议栈，可太重要了。</p><h2><span id="tcp与udp区别">TCP与UDP区别</span></h2><p>常见的，TCP是面向连接的，UDP是面向无连接的。</p><p>在互通之前，面向连接的协议会先建立连接。例如，TCP会三次握手，而UDP不会。</p><blockquote><p>什么是连接呢？</p><p>所谓连接，即是两端的状态维护，中间过程没有所谓的连接，一旦传输失败，一端收到消息，才知道状态的变化</p><p>为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</p></blockquote><ul><li><p><strong>TCP提供可靠交付</strong>。通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达。<strong>UDP继承了IP包的特性，不保证不丢失，不保证按顺序到达。</strong></p></li><li><p><strong>TCP是面向字节流的</strong>。发送的时候发的是一个流，没头没尾。而<strong>UDP继承了IP的特性，基于数据报的，一个一个地发，一个一个地收。</strong></p></li><li><p><strong>TCP是可以有拥塞控制的</strong>。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。<strong>UDP就不会，应用让我发，我就发。</strong></p></li></ul><p>因而<strong>TCP其实是一个有状态服务</strong>，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而<strong>UDP则是无状态服务。</strong></p><h2><span id="udp">UDP</span></h2><h3><span id="包头格式">包头格式</span></h3><p><img src="image-20220322184642440.png" alt="UDP包头格式"></p><p>IP层中的IP头里面定义了传输层是UDP还是TCP协议。</p><p>UDP可以看到格式比较简单，基本上只用到了端口号。</p><h3><span id="udp特点"><strong>UDP</strong>特点</span></h3><p>第一，<strong>沟通简单</strong>，不需要（大量的数据结构、处理逻辑、包头字段）。</p><p>第二，<strong>无需连接</strong>。它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。</p><p>第三，<strong>无拥塞控制</strong>。不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</p><h3><span id="udp的三大使用场景"><strong>UDP的三大使用场景</strong></span></h3><p>第一，<strong>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</strong>。</p><p>第二，<strong>不需要一对一沟通，建立连接，而是可以广播的应用</strong>。</p><p>第三，<strong>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</strong>。</p><hr><p>UDP虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如DHCP、VXLAN、QUIC等。</p><h2><span id="tcp">TCP</span></h2><h3><span id="包头格式"><strong>包头格式</strong></span></h3><p><img src="image-20220322184908909.png" alt="TCP包头格式"></p><p>TCP包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；</p><p><strong>顺序问题</strong>：为了解决包乱序问题，使用“序号”编号，确定先来后到的顺序；确认序号，发出去的包应该有确认，如果没有收到就应该重新发送，直到送达。</p><p><strong>丢包问题</strong>：从IP层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为IP的上一层TCP也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。</p><p><strong>连接维护</strong>：状态位。例如SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p><strong>流量控制</strong>：解决的是发送方和接收方速率不匹配的问题，发送方发送过快接收方就来不及接收和处理。采用的机制是滑动窗口的机制，控制的是发送了但未被Ack的包数量。</p><p><strong>拥塞控制</strong>：解决的是避免网络资源被耗尽的问题，通过大家自律的采取避让的措施，来避免网络有限资源被耗尽。当出现丢包时，控制发送的速率达到降低网络负载的目的。</p><p>流量控制和拥塞控制，一个是对另一端的，一个是针对网络的。</p><h3><span id="tcp的三次握手"><strong>TCP的三次握手</strong></span></h3><img src="image-20220322185046835.png" alt="TCP的三次握手" style="zoom: 67%;"><p>常称为“请求-&gt;应答-&gt;应答之应答”的三个回合。总之，这个流程即是让C/S端都做到消息<strong>一去一回</strong>。</p><p>三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是<strong>TCP包的序号的问题</strong>。</p><p>Client要告诉Server，我这发起的包的序号起始是从哪个号开始的，Server同样也要告诉Client，Server发起的包的序号起始是从哪个号开始的。</p><p>为什么序号不能都从1开始呢？因为这样往往会出现冲突。</p><p>在同一时间，同一序号的包因为重启等各类因素出现在网络上，导致接收错误。</p><p>因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个32位的计数器，每4us加一，如果计算一下，如果到重复，需要4个多小时，那个绕路的包早就死翘翘了，因为我们都知道IP包头里面有个TTL，也即生存时间。</p><h3><span id="tcp四次挥手"><strong>TCP四次挥手</strong></span></h3><img src="image-20220322185359208.png" alt="TCP四次挥手" style="zoom:67%;"><p>你关闭你的发送通道，我关闭我的发送通道。（给对方留下时间准备关闭连接）</p><p>FIN_WAIT_2，如果这个时候Server直接跑路，则Client将永远在这个状态。TCP协议里面并没有对这个状态的处理，但是Linux有，可以调整tcp_fin_timeout这个参数(default 60s)，设置一个超时时间。超时后会直接进入Closed状态。</p><p>TIME_WAIT状态，保证ACK能发送到对端，同时保证对端的包都被当前的Client端消耗掉(免得被下一个使用此端口的client端接收到)。</p><p>若是Client端已经等了2MSL，状态会转至Closed状态。Server超过了2MSL的时间，依然没有收到Client发的FIN的ACK，按照TCP的原理，Server还会重发FIN，这个时候Client再收到这个包之后，Client会直接发送RST，Server就知道Client已经关闭了。</p><p>等待的时间设为2MSL，<strong>MSL</strong>是<strong>Maximum Segment Lifetime</strong>，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为TCP报文基于是IP协议的，而IP头中有一个TTL域，是IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。协议规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p><h3><span id="问题"><strong>问题</strong></span></h3><ul><li>TCP已经有重试机制了，为什么应用层还会写重试？</li></ul><p>应用层重试是解决应用层的错误</p><ul><li>报文最大生存时间（MSL）和IP协议的路由条数（TTL）什么关系呢</li></ul><p>都和报文生存有关，前者是时间维度的概念，后者是经过路由跳数，不是时间单位.</p><hr><p>TCP中的顺序问题、丢包，以及超时传递，滑动窗口、拥塞控制，非常推荐大家阅读<a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">趣谈网络协议</a>“第12讲讲TCP协议（下）”。建议需要的时候拿出来反复理解。</p><p>这里我只提一个TCP队首阻塞的问题，HTTP的队首阻塞是因为HTTP1.1规定先收到的请求要先返回，这样，如果前面的请求耗用太多，就会出现请求队列阻塞的问题。</p><p>我们知道HTTP 2.0解决了这个问题(后面介绍HTTP2.0)，但因为TCP的特性，还是有队首阻塞的问题(这里是传输层的问题，1.1是应用层的问题)。这里需要了解TCP保证顺序性的特性以及滑动窗口的相关知识。</p><p>在TCP协议中，接收端的窗口的起始点是下一个要接收并且ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为TCP的ACK机制是基于序列号的累计应答，一旦ACK了一个系列号，就说明前面的都到了，所以只要前面的没到，后面的到了也不能ACK，就会导致后面的到了，也有可能超时重传，浪费带宽。</p><p><img src="f7b1d3bc6b6d8e55f0951e82294c8ba4.jpg" alt="接收端窗口"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;传输层：UDP和TCP。&lt;/p&gt;
&lt;p&gt;这俩协议真是有太多说的了，毕竟网络里头，TCP/IP协议栈，可太重要了。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;tcp与udp区别&quot;&gt;TCP与UDP区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;常见的，TCP是面向连接的，UDP是面向无连接的。&lt;</summary>
      
    
    
    
    <category term="系统" scheme="chunlife.top/categories/系统/"/>
    
    
    <category term="网络" scheme="chunlife.top/tags/网络/"/>
    
  </entry>
  
  <entry>
    <title>网络知识第一序章</title>
    <link href="chunlife.top/2022/03/17/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%AC%AC%E4%B8%80%E5%BA%8F%E7%AB%A0/"/>
    <id>chunlife.top/2022/03/17/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%AC%AC%E4%B8%80%E5%BA%8F%E7%AB%A0/</id>
    <published>2022-03-17T14:40:29.000Z</published>
    <updated>2022-05-04T04:40:35.122Z</updated>
    
    <content type="html"><![CDATA[<p>趁着这段时间有点时间，把之前了解的零零散散的网络知识笔记都整理了一下，集中回顾一遍，加深一下印象。</p><p>网络方面的东西，我也是后面才去详细了解的，之前知道的都比较片面，对一些点知道的比较浅，也就对UDP、TCP了解的会稍微多一点，后面当我详细去了解的时候，我发现看完之后豁然开朗，就像表面上没改变什么，但实际上对上层的事了解的更多了，很玄妙的感觉。</p><a id="more"></a><h2><span id="http请求发送网络各层级操作一览">HTTP请求发送，网络各层级操作一览</span></h2><img src="image-20220317224215558.png" alt="网络请求协议一览" style="zoom:80%;"><p>对于二层设备、三层设备、四层LB和七层LB的时候，其对应的就是网络协议中的不同层级。</p><p>网络中的上下层，其实更具体的说是内外层，最外层是MAC地址，最内层是HTTP包。</p><p>发送端类似于打包，接收端类似于拆封。</p><p>当一个网络包从一个网口经过的时候，你看到了，首先先看看要不要请进来，处理一把。有的网口配置了<em>混杂模式</em>，凡是经过的，全部拿进来。</p><p>所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个HTTP协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面HTTP、TCP、 IP、 MAC都有。什么叫二层设备呀，就是只把MAC头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢？就是把MAC头摘下来之后，再把IP头摘下来，看看到底是丢弃、转发，还是自己留着。</p><h2><span id="四层-七层负载均衡">四层、七层负载均衡</span></h2><p><img src="L4-L7.png" alt="L4-L7"></p><p><img src="image-20220317224604271.png" alt="OSI七层网络模型"></p><p>负载均衡又分为四层负载均衡和七层负载均衡。四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。</p><p>七层负载均衡工作在OSI模型的应用层，因为它需要解析应用层流量，所以七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是代理。</p><blockquote><p>图自：<a href="https://tech.meituan.com/2017/01/05/mgw.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/01/05/mgw.html</a></p></blockquote><p>L4负载均衡，更准确的术语是“第 3/4 层负载平衡”——因为负载平衡器的决定基于两个 IP 地址源服务器和目标服务器（第 3 层）以及应用程序的 TCP 端口号（第 4 层）。“第 7 层负载平衡”更准确的术语可能是“第 5 层到第 7 层负载平衡”，因为 HTTP 结合了 OSI 第 5、6 和 7 层的功能。</p><ul><li><p>问：图中为什么经过L4转发是直连到后端server，L7不是？</p></li><li><p>答：L4是基于传输层，也就是TCP/UDP这一层，以TCP为例，看看TCP包头的格式以及IP包头格式：</p></li></ul><img src="image-20220317224437459.png" alt="TCP包头格式" style="zoom: 50%;"><img src="image-20220317224819948.png" alt="IP以及MAC头" style="zoom: 67%;"><p>一个完整的网络如下：</p><p><img src="%E7%BD%91%E7%BB%9C%E5%8C%85.png" alt="完整包"></p><p>客户端向负载均衡发送SYN请求建立第一次连接，通过配置的负载均衡算法选择一台后端服务器，并且将报文中的IP地址信息修改为后台服务器的IP地址信息，<strong>因此TCP三次握手连接是与后端服务器直接建立起来的。</strong></p><p>七层服务均衡在应用层选择服务器，只能先与负载均衡设备进行TCP连接，<strong>然后负载均衡设备再与后端服务器建立另外一条TCP连接通道。</strong></p><p>到L7 Server时，网络包已经被扒得只剩下HTTP数据了，无法做更多的更底层协议的操作。但更方便做数据清洗，因为这已经是原始的数据了，可以根据规则筛选数据。</p><h2><span id="dhcp动态分配ip">DHCP动态分配IP</span></h2><p>Linux 通过判断判断IP的网段，来判断一个IP是否与自己处于同一网络环境内。（至于实际其是否在同一环境则未知）。</p><p>在同一网段，它才会发送ARP请求，获取MAC地址。</p><p><strong>如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。</strong></p><p>如果你配置了网关的话，Linux会获取网关的MAC地址，然后将包发出去。</p><p>如果没有配置网关呢？那包压根就发不出去。</p><p>IP配置：<strong>不同系统的配置文件格式不同，但是无非就是CIDR、子网掩码、广播地址和网关地址</strong>。</p><ul><li>CIDR： 10.100.122.2/24，24的意思是，32位中，前24位是网络号，后8位是主机号。一般家里地上网设备不会超过256个，所以/24基本就够了。有时候我们也能见到/16的CIDR，这两种是最常见的，也是最容易理解的。</li><li>广播地址，10.100.122.255</li><li>子网掩码，255.255.255.0</li></ul><hr><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作， 主要给内部网络或 网络服务供应商自动分配 IP地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Title: DHCP数据发送过程</span><br><span class="line"></span><br><span class="line">    participant client as 客户端</span><br><span class="line">    participant server as DHCP服务器</span><br><span class="line"></span><br><span class="line">    client -&gt;&gt; server: 广播DHCP Discover</span><br><span class="line">    server -&gt;&gt; client: 为客户端保留IP地址(DHCP Offer)</span><br><span class="line">    client -&gt;&gt; server: 选择并接受一个地址(DHCP Request)</span><br><span class="line">    server -&gt;&gt; client: 确认客户端IP地址(DHCP ACK)</span><br></pre></td></tr></table></figure><p>客户机会在租期过去50%的时候，直接向为其提供IP地址的DHCP Server发送DHCP request消息包。</p><p>客户机接收到该服务器回应的DHCP ACK消息包，会根据包中所提供的新的租期以及其他已经更新的TCP/IP参数，更新自己的配置。这样，IP租用更新就完成了。</p><h2><span id="物理层到mac层">物理层到MAC层</span></h2><h3><span id="物理层">物理层</span></h3><p>正常两台电脑是可以直接互联的，需要配置这两台电脑的IP地址（相同网段）、子网掩码和默认网关。再配上一根交叉网线。（以前不同，还以为网线都是一类——交叉直连网线，后面搞嵌入式才发现交叉、直连是两种网线，当前网卡已可以自适应）</p><p>两台电脑互联即构成局域网，即LAN。</p><p>多台电脑也可以使用集线器（Hub）。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</p><h3><span id="mac层数据链路层">MAC层（数据链路层）</span></h3><p><strong>多电脑连接中，Hub采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都能收到。传输数据过程中易产生冲突，带宽利用率不高</strong></p><p>MAC层就是用来解决多路访问的堵车问题的。而交换机的出现也是在解决了在广播的情况下，避免冲突的产生。</p><p>不使用广播方式，就需要解决几个问题：</p><ol><li>这个包是发给谁的？谁应该接收？</li><li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li><li>如果发送的时候出现了错误，怎么办？</li></ol><p><strong>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</strong></p><p><strong>MAC</strong>的全称是<strong>Medium Access Control</strong>，即<strong>媒体访问控制。<strong>控制在往媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱。这解决的是第二个问题。这个问题中的规则，学名叫</strong>多路访问</strong>。以太网中使用<strong>随机接入协议。</strong>（需要发就发，网络堵塞的适合就等会再发）</p><p>解决了第二个问题，就是解决了媒体接入控制的问题，MAC的问题也就解决好了。这和MAC地址没什么关系。</p><p><strong>这个包是发给谁的？谁应该接收？</strong></p><p>这里用到一个物理地址，叫作**链路层地址。**但是因为第二层主要解决媒体接入控制的问题，所以它常被称为MAC地址。</p><p>解决第一个问题就牵扯到第二层的网络包<strong>格式</strong>。对于以太网，第二层的最开始，就是目标的MAC地址和源的MAC地址。</p><p><img src="image-20220317225546905.png" alt="MAC包头"></p><p>接下来是类型，大部分的类型是IP数据包，然后IP里面包含TCP、UDP，以及HTTP等，这都是里层封装的事情。</p><p>有了这个目标MAC地址，数据包在链路上广播，MAC的网卡才能发现，这个包是给它的。MAC的网卡把包收进来，然后打开IP包，发现IP地址也是自己的，再打开TCP包，发现端口是自己，也就是80，而nginx就是监听80。</p><p>对于以太网，第二层的最后面是<strong>CRC</strong>，也就是<strong>循环冗余检测</strong>。通过XOR异或的算法，来计算整个包是否在发送的过程中出现了错误，主要解决第三个问题。</p><p>正常情况下是只知道对方的IP，不知道MAC地址的，这就需要用到<strong>ARP协议</strong>，就是已知IP地址，求MAC地址的协议。即发送一个广播包，谁是这个IP谁来回答。为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP的MAC地址缓存过一段时间就会过期。</p><p>交换机是有MAC地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。</p><hr><p>总结：</p><p>Hub：</p><p>1.一个广播域，一个冲突域。</p><p>2.传输数据的过程中易产生冲突，带宽利用率不高</p><p>Switch：</p><p>1.在划分<code>vlan</code>的前提下可以实现多个广播域，每个接口都是一个单独的冲突域</p><p>2.通过自我学习的方法可以构建出CAM表，并基于CAM进行转发数据。</p><p>3.支持生成树算法（STP，全称Spanning Tree Protocol）。可以构建出物理有环，逻辑无环的网络，网络冗余和数据传输效率都甩Hub好几条街。SW是目前组网的基本设备之一。</p><blockquote><p><em>CAM表，我理解其就是<strong>MAC</strong>表，也就是<strong>MAC</strong>地址与<strong>Port</strong>的对应的一个<strong>table</strong>。</em></p><p><em>冲突域（物理分段）：同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合</em></p><p><em>广播域：接收同样广播消息的节点的集合</em></p></blockquote><p>交换机MAC头：</p><p><img src="%E4%BA%A4%E6%8D%A2%E6%9C%BAMAC%E5%A4%B4.png" alt="交换机MAC头"></p><p>这样只有相同VLAN ID的包，才会互相转发，不同VLAN的包，是看不到的。</p><p>我们可以设置交换机每个口所属的VLAN。</p><p>交换机之间通过<strong>Trunk口</strong>连接，它可以转发属于任何VLAN的口。</p><p><strong>如果没有STP算法：</strong></p><p>ARP广播时，交换机会将一个端口收到的包转发到其它所有的端口上。</p><p>比如数据包经过交换机A到达交换机B，交换机B又将包复制为多份广播出去。</p><p>如果整个局域网存在一个环路，使得数据包又重新回到了最开始的交换机A，这个包又会被A再次复制多份广播出去。</p><p>如此循环，数据包会不停得转发，而且越来越多，最终占满带宽，或者使解析协议的硬件过载，行成广播风暴。</p><h2><span id="icmp与ping">ICMP与Ping</span></h2><p>ICMP相当于网络世界的侦察兵。有两种类型的ICMP报文，一种是主动探查的查询报文，一种异常报告的差错报文；</p><p>ping使用查询报文，Traceroute使用差错报文。(其在网络层，自然包裹IP头)</p><img src="image-20220317230204200.png" alt="ICMP报文" style="zoom:80%;"><p><strong>查询报文，是一种主动请求，并且获得主动应答的ICMP协议。</strong></p><p>对ping的主动请求，进行网络抓包，称为<strong>ICMP ECHO REQUEST</strong>。同理主动请求的回复，称为<strong>ICMP ECHO REPLY</strong>。</p><ul><li>标识符：区别不同的功能包；</li><li>序号：一组包的编号；</li><li>数据：ping还会存放发送请求的时间值，来计算往返时间，说明路程的长短</li></ul><p><strong>差错报文类型</strong>，返回时，类型代表出错类型。例如<strong>终点不可达为3，源抑制为4，超时为11，重定向为5</strong>。</p><p>差错报文后面是跟上出错的那个IP包的IP头和IP正文的前8个字节。</p><p><strong>Traceroute</strong>：</p><ul><li><strong>故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器</strong></li></ul><p>使用IP header的TTL（Time To Live）这个field，Traceroute的参数指向某个目的IP地址，它会发送一个UDP的数据包。将TTL设置成1，路由器拿到包后将TTL减1，TTL为0，则会返回ICMP time exceeded</p><p>怎么知道UDP有没有到达目的主机呢？Traceroute程序会发送一份UDP数据报给目的主机，但它会选择一个不可能的值作为UDP端口号（大于30000）。当该数据报到达时，将使目的主机的 UDP模块产生一份“端口不可达”错误ICMP报文。如果数据报没有到达，则可能是超时。</p><ul><li><strong>故意设置不分片，从而确定路径的MTU(最大传输单元)</strong></li></ul><p>若ICMP差错报文自身出错，则不再发送关于差错报文的差错报文。</p><p><strong>为何传递UDP包其返回ICMP报文？</strong></p><p>协议栈能正常走到UDP，就正常返回UDP。</p><p>还没到UDP和TCP的传输层，所以UDP出错可以返回ICMP差错报文。（ICMP属于网络层，是管理和控制IP的一种协议）</p><h2><span id="参考文献">参考文献</span></h2><p><a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">趣谈网络协议</a></p><p><a href="https://tech.meituan.com/2017/01/05/mgw.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/01/05/mgw.html</a></p><p><a href="https://blog.csdn.net/ugly_girl/article/details/80901887" target="_blank" rel="noopener">冲突域和广播域的区分</a></p><p><a href="https://blog.csdn.net/q235990/article/details/88177202" target="_blank" rel="noopener">网络: 快速理解NAT与NAPT的区别</a></p><p><a href="https://blog.csdn.net/qq_35733751/article/details/80053091" target="_blank" rel="noopener">11-ICMP差错报告报文</a></p><p><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">What Is Layer 4 Load Balancing?</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着这段时间有点时间，把之前了解的零零散散的网络知识笔记都整理了一下，集中回顾一遍，加深一下印象。&lt;/p&gt;
&lt;p&gt;网络方面的东西，我也是后面才去详细了解的，之前知道的都比较片面，对一些点知道的比较浅，也就对UDP、TCP了解的会稍微多一点，后面当我详细去了解的时候，我发现看完之后豁然开朗，就像表面上没改变什么，但实际上对上层的事了解的更多了，很玄妙的感觉。&lt;/p&gt;</summary>
    
    
    
    <category term="系统" scheme="chunlife.top/categories/系统/"/>
    
    
    <category term="网络" scheme="chunlife.top/tags/网络/"/>
    
  </entry>
  
  <entry>
    <title>从Linux架构中学习开发</title>
    <link href="chunlife.top/2022/03/10/%E4%BB%8ELinux%E6%9E%B6%E6%9E%84%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91/"/>
    <id>chunlife.top/2022/03/10/%E4%BB%8ELinux%E6%9E%B6%E6%9E%84%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91/</id>
    <published>2022-03-10T12:11:28.000Z</published>
    <updated>2022-05-04T04:40:35.104Z</updated>
    
    <content type="html"><![CDATA[<p>软件架构大多数情况下不会影响我们将来上线产品，但糟糕的代码必然会堆积成山，由我们未来背负。这里我们首先要明白软件开发的两个难点：</p><p>技术难，代码量可能不多，但都是一些比较核心的需要攻坚型的问题，不是靠“堆人”就能搞定的，比如自动驾驶、图像识别、高性能消息队列等；</p><p>复杂度，意思是说，技术不难，但项目很庞大，业务复杂，代码量多，参与开发的人多，比如物流系统、财务系统等。</p><p>而恰好，<strong>软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。</strong></p><h2><span id="封装与抽象">封装与抽象</span></h2><p>“一切皆文件”就体现了封装和抽象的设计思想。</p><p>封装了不同类型设备的访问细节，抽象为统一的文件访问方式，更高层的代码就能基于统一的访问方式，来访问底层不同类型的设备。这样做的好处是，隔离底层设备访问的复杂性。统一的访问方式能够简化上层代码的编写，并且代码更容易复用。</p><p>除此之外，抽象和封装还能有效控制代码复杂性的蔓延，将复杂性封装在局部代码中，隔离实现的易变性，提供简单、统一的访问接口，让其他模块来使用，其他模块基于抽象的接口而非具体的实现编程，代码会更加稳定。</p><hr><p>这里包括底层驱动都做了很多封装和抽象，实现一个新的驱动程序也只用填充已经规范好的<code>handler</code>，其他的无需多少考虑。</p><h2><span id="分层与模块化">分层与模块化</span></h2><p>不同的模块之间通过接口来进行通信，模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样，将各个模块组装起来，构建成一个超级复杂的系统。</p><p>面对复杂系统的开发，我们要善于应用分层技术，把容易复用、跟具体业务关系不大的代码，尽量下沉到下层，把容易变动、跟具体业务强相关的代码，尽量上移到上层。</p><hr><p>对于Linux来说，还是拿驱动举例，一个PCI的串口设备，首先其是PCI设备，其又是serial设备，那将它整体注册到PCI总线上，初始化完PCI相关的之后，实际操作代码还是串口设备的方式。</p><p>分层也在DDD中体现的很明显，像repo层，专注于与数据进行交互，业务代码上浮，这样，BIZ层不需要关心底层数据库是否变化，只用具体关心数据拿到手之后做什么操作。</p><h2><span id="基于接口通信">基于接口通信</span></h2><p>依赖接口，而不是依赖具体的实现。</p><p>暴露给其他层的是接口，屏蔽复杂实现于接口内部，这样内部修改，也不会影响到其他层的代码。</p><h2><span id="高内聚-松耦合">高内聚、松耦合</span></h2><p>这个更多的是一个通用的设计思想，代码符合以上的设计理念，其自然也就符合高内聚，低耦合。</p><p>我的理解是，功能上模块进行聚合，集中在几个实例中，对外界依赖少，代码集中。向外提供接口，向内调用接口。</p><h2><span id="为扩展而设计">为扩展而设计</span></h2><p>识别出代码可变部分和不可变部分，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，供上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><hr><p>我的理解是，已经实现的接口在保持不变的前提下（面子），继承该接口，改变某个接口内部功能，完成功能扩展。</p><h2><span id="kiss首要原则">KISS首要原则</span></h2><p>不管是自己还是团队，在参与大型项目开发的时候，要尽量避免过度设计、过早优化，在扩展性和可读性有冲突的时候，或者在两者之间权衡，模棱两可的时候，应该选择遵循KISS原则，首选可读性。</p><hr><p>这个深有体会，在实际开发过程中，没有必要提前设想的，不要实现，比如某个功能可以动态变化，但当前以及可见的未来并不需要此功能，实际做出来就很复杂，反而当前的设计都会很难用。</p><h2><span id="最小惊奇原则">最小惊奇原则</span></h2><p>在做设计或者编码的时候要遵守统一的开发规范，避免反直觉的设计。</p><hr><p>在Go中，可能会好一点，毕竟代码风格比较统一，但实际还会有很多写代码时，用法上出现很多问题，这个问题，我觉得还是得靠code review和lint工具来解决，由上至下，加上强制工具。</p><h2><span id="总结">总结</span></h2><p>在开发中，经常听到的就是，<strong>我们可以未来再重构代码，产品上线最重要</strong>，但实际上重构永远不会来，往往自己欺骗自己，屎山代码就是这么来的，而且<code>熵增</code>是持续的，若不从最开始控制结构，那结构往往从一开始就不复存在。</p><h2><span id="参考文献">参考文献</span></h2><p><a href="https://time.geekbang.org/column/intro/100039001" target="_blank" rel="noopener">设计模式之美</a></p><p><a href="https://mp.weixin.qq.com/s/ZCoc3qA_r1fKzPOURA2V2g" target="_blank" rel="noopener">从Kratos设计看Go微服务工程实践</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件架构大多数情况下不会影响我们将来上线产品，但糟糕的代码必然会堆积成山，由我们未来背负。这里我们首先要明白软件开发的两个难点：&lt;/p&gt;
&lt;p&gt;技术难，代码量可能不多，但都是一些比较核心的需要攻坚型的问题，不是靠“堆人”就能搞定的，比如自动驾驶、图像识别、高性能消息队列等；</summary>
      
    
    
    
    <category term="编程技术" scheme="chunlife.top/categories/编程技术/"/>
    
    
    <category term="设计模式" scheme="chunlife.top/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>Frangipani: A Scalable Distributed File System 翻译 上</title>
    <link href="chunlife.top/2022/01/03/Frangipani-A-Scalable-Distributed-File-System/"/>
    <id>chunlife.top/2022/01/03/Frangipani-A-Scalable-Distributed-File-System/</id>
    <published>2022-01-02T19:21:05.000Z</published>
    <updated>2022-05-04T04:40:35.075Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="frangipani-一个可伸缩的分布式文件系统">Frangipani: 一个可伸缩的分布式文件系统</span></h1><h2><span id="摘要">摘要</span></h2><p>理想的分布式文件系统应该为所有用户提供对同一组文件的一致的统一的访问，并且可以任意伸缩，以便为不断增长的用户社区提供更多的存储空间和更高的性能。尽管组件出现故障，但它仍然具有很高的可用性。这将需要最少的人工管理，并且随着添加更多组件，管理不会变得更加复杂。</p><p>Frangipani是一种新的文件系统，它近似于这种理想状态，而且由于它的两层结构，构建起来相对容易。底层是Petal(在之前的文章描述过)，这是一种分布式存储服务，提供可扩展、高可用性、自动管理的虚拟磁盘。在上层，多台机器在共享的Petal虚拟磁盘上运行相同的Frangipani文件系统代码，使用分布式锁服务来确保一致性。</p><p>Frangipani是在拥有统一管理下的集群中运行的，可以安全的通信。因此，机器之间相互信任，共享虚拟磁盘方法是可行的。当然，Frangipani文件系统可以使用普通网络文件访问协议剔除不受信任的机器。</p><p>我们在运行数码UNIX 4.0的<code>AlphaS</code>集合上实施了Frangipani。初始测量表明，Frangipani随着服务器的增加，其依然具有优异的单服务器性能和可扩展性。</p><h2><span id="1-介绍">1  介绍</span></h2><p>使用当下技术构建的可应用于大型、持续增长的计算机集群的文件管理系统，处理现有业务来说是一项艰巨的任务。其困局是，为了保存更多文件并为更多用户提供服务，必须添加更多磁盘，连接到更多机器上。 这些组件中的每一个都需要人工维护。 文件组通常手动分配到特定磁盘，然后在组件装满、出现故障或成为性能热点时手动移动或复制。 使用RAID技术将多个磁盘驱动器连接成一个单元只是部分解决方案；当系统变得足够大，需要多个raid和多个服务器时，仍然会出现管理问题。</p><p>Frangipani是一种新的可扩展的分布式文件系统，它将多台机器上的磁盘集合管理为一个共享存储池。假定这些机器处于共同的管理之下，并且能够安全地通信。在构建分布式文件系统方面，已经有很多早期的尝试，它们在吞吐量和容量上都有很好的扩展性[1,11,19,20,21,22,26,31,33,34]。Frangipani的一个显著特征是它有一个非常简单的内部结构—一组相互协作的机器使用一个公共存储并用锁同步对该存储的访问。这个简单的结构使我们能够用很少的机器处理系统恢复、重新配置和负载平衡。Frangipani的另一个关键在于，它结合了一组特性，使其比我们所知道的现有文件系统更容易使用和管理Frangipani。</p><ol><li>所有用户都会给出相同一组文件的一致视图。</li><li>可以轻松地将更多服务器添加到现有Frangipani集群中，以增加其存储容量和吞吐量，而无需更改现有服务器的配置或中断其操作。这些服务器可以被看作是“砖块”，可以增量堆叠，以根据需要构建尽可能大的文件系统。</li><li>系统管理员可以添加新用户，而无需考虑哪些计算机将管理其数据或哪些磁盘将存储数据。</li><li>系统管理员可以在不关闭整个文件系统的情况下对整个文件系统进行完整且一致的备份。备份可以在线保存，允许用户快速访问意外删除的文件。</li><li>文件系统能够容忍机器、网络和磁盘故障，并在无需操作员干预的情况下进行恢复。</li></ol><p>Frangipani位于Petal[24]之上，Petal是一个易于管理的分布式存储系统，它为客户端提供虚拟磁盘。与物理磁盘一样，Petal虚拟磁盘提供了可以在块中读写的存储空间。与物理磁盘不同，虚拟磁盘提供不连续的2<sup>64</sup>字节地址空间，物理存储空间按需分配。Petal可以选择性的复制数据以实现高可用性。Petal还提供了高效的快照[7,10]来支持一致的备份。Frangipani从底层存储系统继承了许多可伸缩性、容错性和易于管理的特性，但是需要仔细设计才能将这些属性扩展到文件系统级别。下一节将详细介绍Frangipani的结构及其与Petal的关系。</p><p><img src="image-20220103003019974-16411513573451.png" alt="图1：Frangipani分层。几个可互换的Frangipani服务器提供对一个Petal虚拟磁盘上的一组文件的访问"></p><p>图1演示了Frangipani系统中的分层。多个可互换的Frangipani服务器通过在共享的Petal虚拟磁盘上运行来提供对相同文件的访问，用锁来协调它们的操作，以确保一致性。文件系统层可以通过添加Frangipani服务器来缩放。它通过自动从服务器故障中恢复并继续使用幸存的服务器来实现容错。它在单一的网络文件服务器上提供了改进的负载平衡，通过分流文件系统负载并将其转移到正在使用这些文件的机器上。Petal和锁服务也被用于在可伸缩性、容错和负载平衡方面。</p><p>Frangipani服务器，Petal服务器和锁服务相互信任。Frangipani设计之初用于在单个管理域内的工作站集群中运行良好，但Frangipani文件系统可以导出到其他域。因此，Frangipani可以看作是一个集群文件系统。</p><p>我们已经在DIGITAL Unix 4.0下实现了Frangipani。由于Frangipani在现有Petal服务之上的清晰分层，我们能够在短短几个月内实现一个工作系统。</p><p>Frangipani针对具有程序开发和工程工作负载的环境。我们的测试表明，在此类工作负载上，Frangipani具有出色的性能，并缩小网络限制。</p><h2><span id="2-系统结构">2  系统结构</span></h2><p>图2描述了系统的一个经典情况。上面显示的机器运行用户程序和Frangipani文件服务器模块；它们可以是无磁盘的。底部显示的运行Petal和分布式锁服务。</p><p><img src="image-20220103005242815-16411513573463.png" alt="图2：Frangipani结构。在一个典型的Frangipani配置中，一些机器运行用户程序和Frangipani文件服务器模块；另一些运行Petal和分布式锁服务。在其他配置中，相同的机器可能同时扮演这两个角色。"></p><p>Frangipani的组件不必完全按照图2所示的方式分配给机器。Frangipani和Petal服务器不需要在单独的机器上；每台Petal机器也可以运行Frangipani，特别是在花瓣机器没有重载的情况下。分布式锁服务独立于系统的其他部分;我们展示了在每台Petal服务器上运行一个lock服务器，但它们也可以在Frangipani主机或任何其他可用的机器上运行。</p><h3><span id="21-组件">2.1  组件</span></h3><p>如图2所示，用户程序通过标准操作系统调用接口访问Frangipani。在不同机器上运行的程序都看到相同的文件，它们的视图是一致的；也就是说，对一台计算机上的文件或目录所做的更改在所有其他计算机上都立即可见。程序基本上得到了与本地Unix文件系统相同的语义保证：对文件内容的更改通过本地内核缓冲池暂存，在下一次适用的fsync或sync系统调用之前不能保证到达非易失性存储，但是元数据的更改会被记录下来，并且可以选择在系统调用返回时保证为非易失性。与本地文件系统语义稍有不同的是，Frangipani仅粗略地维护一个文件的最后访问时间，以避免每次读取数据时都进行元数据写操作</p><blockquote><p>元数据：将元数据定义为除普通文件内容以外的任何磁盘数据结构。</p></blockquote><p>每台机器上的Frangipani文件服务器模块在操作系统内核内运行。它将自己注册到内核的文件系统中，作为可用的文件系统实现之一。文件服务器模块使用内核的缓冲池来缓存最近使用的文件中的数据。它使用本地Petal设备驱动程序读取和写入Petal虚拟磁盘。所有文件服务器在共享Petal磁盘上读取和写入相同的文件系统数据结构，但每个服务器在Petal磁盘的不同部分保留其自己的挂起更改重做日志。日志保存在Petal中，以便在Frangipani服务器崩溃时，另一台服务器可以访问日志并运行恢复。Frangipani服务器之间不需要直接通信；它们只与Petal和锁服务通信。这使服务器的添加、删除和恢复变得简单。</p><p>Petal设备驱动程序隐藏了Petal的分布式特性，使得Petal对于操作系统的更高层来说就像一个普通的本地磁盘。驱动程序负责于对应的Petal服务器通信，并在发生故障时切换到另一个服务器。任何Digital Unix文件系统都可以在Petal上运行，但只有Frangipani提供了从多台机器对相同文件的一致访问。</p><p>Petal服务器协同运行，为Frangipani提供大型的、可伸缩的、容错的虚拟磁盘，这些虚拟磁盘是在连接到每个服务器的普通物理磁盘之上实现的。Petal可以容忍一个或多个磁盘或服务器故障，只要Petal服务器的大部分保持正常并保持通信，每个数据块至少有一个副本保持物理上可访问。花瓣的更多细节可在另一份文件[24]。</p><p>锁服务是一种通用服务，它向网络上的客户端提供<code>多读/单写</code>锁。它的实现是分布式的，以容错和可扩展的性能。Frangipani使用锁服务来协调对虚拟磁盘的访问，并在多个服务器上保持缓冲区缓存一致。</p><h3><span id="22-安全和客户端服务器配置">2.2  安全和客户端/服务器配置</span></h3><p>在图2所示的配置中，运行用户程序的每台计算机也运行一个Frangipani文件服务器模块。这种配置有可能实现良好的负载平衡和扩展，但会带来安全问题。任何Frangipani机器都可以读取或写入共享Petal虚拟磁盘的任何块，因此Frangipani必须仅在具有可信操作系统的机器上运行；Frangipani机器向Petal验证自己是否代表特定用户是不够的，就像在NFS等远程文件访问协议中所做的那样。完全安全性还要求Petal服务器和锁服务器在受信任的操作系统上运行，并要求所有三种类型的组件彼此进行身份验证。最后，为了确保文件数据保密，应防止用户在连接Petal和Frangipani机器的网络上窃听。</p><p>通过将机器放置在一个环境中，防止用户在机器上启动修改过的操作系统内核，并将其与用户进程无权访问的专用网络互连，可以完全解决这些问题。这并不一定意味着必须将机器锁定在具有专用物理网络的房间中；可以使用已知的用于安全引导、身份验证和加密链接的加密技术[13,37]。此外，在许多应用中，部分解决方案是可以接受的；典型的现有NFS安装对于在工作站上引导修改过的内核的用户的网络窃听甚至数据修改都不安全。到目前为止，我们还没有实施任何这些安全措施，但是我们可以通过让Petal服务器只接受来自属于受信任的Frangipani服务器机器的网络地址列表的请求，大致达到NFS安全级别。</p><p>Frangipani文件系统可以使用图3所示的配置导出到管理域之外的不受信任的机器。这里我们区分Frangipani客户端和服务器。只有受信任的Frangipani服务器与Petal和锁服务通信。它们可以位于受限环境中，并通过如上所述的专用网络互连。远程、不受信任的客户端通过单独的网络与Frangipani服务器通信，无法直接访问Petal服务器。</p><p><img src="image-20220103011830187-16411513573462.png" alt="图3:客户机/服务器配置 Frangipani服务器不仅可以为本地计算机提供文件访问，还可以为通过标准网络文件系统协议连接的远程客户端计算机提供文件访问。"></p><p>客户端可以使用主机操作系统支持的任何文件访问协议（如DCE/DFS、NFS或SMB）与Frangipani服务器通信，因为Frangipani看起来就像运行Frangipani服务器的机器上的本地文件系统。当然，一个支持一致性访问的协议(例如 DCE/DFS)是最好的，这样Frangipani跨多个服务器的一致性就不会在下一级丢失。( ? )   理想情况下，该协议还应该支持从一个Frangipani服务器到另一个Frangipani服务器的故障转移。刚才提到的协议不直接支持故障转移，但是让新机器接管故障机器的IP地址的技术已经在其他系统中使用过[3,25]，也可以在这里应用。</p><p>除了安全性之外，使用此客户机/服务器配置还有第二个原因。因为Frangipani在内核中运行，所以它不能在不同的操作系统甚至不同版本的Unix之间快速移植。客户端可以通过远程访问受支持的系统，从不受支持的系统使用Frangipani。</p><h3><span id="23-讨论">2.3  讨论</span></h3><p>将文件系统分为两层构建的想法——较低级别提供存储库，较高级别提供名称、目录和文件——并不是Frangipani所独有的。我们知道的最早的例子是通用文件服务器[4]。然而，Petal提供的存储设施与早期的系统有很大不同，这也导致了不同的更高级别结构。第10节包含与以前系统的详细比较。</p><p>Frangipani的设计目的是与Petal提供的存储空间配合使用。我们还没有充分考虑开发NASD等替代存储抽象所需的设计更改[13]。</p><p>Petal提供了高可用性存储，可以随着资源的添加而扩展吞吐量和容量。然而，Petal没有提供在多个客户端之间协调或共享存储的功能。此外，大多数应用程序不能直接使用Petal的客户端接口，因为它是磁盘类型而不是文件类型。Frangipani提供了一个文件系统层，使Petal在保留和扩展其良好属性的同时对应用程序有用。</p><p>Frangipani的优势在于它允许透明的添加服务器、删除和故障恢复。通过将预写式日志和锁与一个统一的可访问的、高可用性的存储结合起来，它能够轻松地做到这一点。</p><p>Frangipani的另一个优势是它能够在系统运行时创建一致的备份。第8节讨论了Frangipani的备份机制。</p><p><img src="image-20220103015153021-16411513573464.png" alt="图4:磁盘布局。 Frangipani利用Petal巨大而不连续的磁盘地址空间来简化其数据结构。每个服务器都有自己的日志和自己的分配位图空间块。"></p><p>Frangipani的设计有三个方面可能会有问题。将Frangipani与复制的Petal虚拟磁盘一起使用，意味着日志记录有时会发生两次，一次是到Frangipani日志，另一次是在Petal本身。其次，Frangipani在放置数据时不使用磁盘位置信息，事实上它不能，因为Petal虚拟了磁盘。最后，Frangipani锁定整个文件和目录，而不是单个块。我们没有足够的使用经验来评估我们设计的这些方面，但尽管如此，Frangipani在我们测试的工程工作负载上的测量性能还是不错的。</p><h2><span id="3-磁盘布局">3  磁盘布局</span></h2><p>Frangipani使用Petal的大而稀疏的磁盘地址空间来简化其数据结构。这个总体思路让人想起了过去在大内存地址空间的计算机编程工作。有这么多的地址空间可用，可以慷慨地将其分割开来。</p><p>Petal虚拟磁盘有2<sup>64</sup>字节的地址空间。Petal仅在写入虚拟地址时才将物理磁盘空间提交给虚拟地址。Petal还提供了一个decommit原语，可以释放支持一系列虚拟磁盘地址的物理空间。</p><p>为了保持内部数据结构的小型化，Petal以相当大的块（目前为64 KB）提交和释放空间。也就是说，每个64 KB的地址范围【a*2<sup>16</sup>，(a+1)*2<sup>16</sup>】（其中一些数据已写入且未解除提交）都分配有64 KB的物理磁盘空间。因此，Petal客户机不能使其数据结构过于稀疏，否则过多的物理磁盘空间将因碎片化而被浪费。图4显示了Frangipani是如何划分其虚拟磁盘空间的。</p><p>第一个区域存储共享的配置参数和内务管理信息(housekeeping information,<code>不太理解</code>)。我们允许这个区域有一兆字节（TB）的虚拟空间，但实际上目前只使用了其中的几千字节。</p><p>第二个区域存储日志。每台Frangipani服务器获得 一部分空间来存放它的私人日志。我们已经为这个区域保留了 1TB（2<sup>40</sup>字节）给这个区域，划分为256个日志。这 这个选择限制了我们目前的实施，使其只能容纳256个服务器，但这很容易进行调整。</p><p>第三个区域用于分配位图，以描述剩余区域中的哪些块是空闲的。每个Frangipani服务器都会锁定位图空间的一部分以供其专用。当服务器的位图空间填满时，它会查找并锁定另一个未使用的部分。位图区域的长度为3 TB。</p><p>第四个区域存放节点。每个文件都需要一个<code>inode</code>来保存其元数据，如时间戳和指向其数据位置的指针。符号链接将其数据直接存储在inode节点中。我们将节点的长度定为512字节，也就是一个磁盘块的大小，从而避免了服务器之间不必要的争夺（“虚假共享”），如果两个服务器需要访问同一块中的不同节点，就会出现这种情况。我们分配了1TB的节点空间，允许2<sup>31</sup>个节点的空间。分配位图和节点之间的映射是固定的，所以每个Frangipani服务器只从与分配位图的部分相对应的节点空间中为新文件分配节点。但任何Frangipani服务器都可以读取、写入或释放任何现有文件的节点。</p><p>第五个区域存放小数据块，每个4 KB（2<sup>12</sup>字节）大小。一个文件的前64 KB（16个块）被存储在小块中。如果一个文件增长到超过64KB，剩下的就存储在一个大块中。我们为小块分配2<sup>47</sup>个字节，因此最多允许有2<sup>35</sup>个小块，是最大节点数的16倍。</p><p>Petal地址空间的其余部分存放大数据块。每个大数据块都保留了1TB的地址空间。</p><p>我们使用4KB块的磁盘布局策略可能会比更谨慎地支配磁盘空间的策略遭受更多的碎片。另外，为每个节点分配512字节的空间也有些浪费。我们可以通过将小文件存储在inode本身来缓解这些问题[29]。我们的设计所获得的是简单性，我们相信这对于额外的物理磁盘空间的成本来说是一个合理的权衡。</p><p>目前的方案将Frangipani限制在略低于2<sup>24</sup>（1600万）大文件，其中大文件是指大于64KB的任何文件。另外，任何文件都不能大于16个小块加一个大块（64KB加1TB）。如果这些限制被证明太小，我们可以很容易地减少大块的大小，从而使更多的数量可用，并允许大文件跨越一个以上的大块，从而提高最大文件大小。如果2<sup>64</sup>字节的地址空间限制被证明是不够的，一个Frangipani服务器可以在多个虚拟磁盘上支持多个Frangipani文件系统。</p><p>我们根据早期文件系统的使用经验，选择了这些文件系统参数。我们相信我们的选择将为我们提供良好的服务，但只有时间和使用才能证实这一点。Frangipani的设计足够灵活，我们可以以文件系统的备份和恢复为代价来试验不同的布局。</p><blockquote><p>在本节中，文件一词包括目录、符号链接等。</p></blockquote><h2><span id="4-记录和恢复">4 记录和恢复</span></h2><p>Frangipani使用元数据的预写重做日志记录来简化故障恢复并提高性能；用户数据不被记录。每个Frangipani服务器在Petal中都有自己的私有日志。当Frangipani文件服务器需要进行元数据更新时，它首先创建一个描述更新的记录，并将其附加到其内存中的日志中。这些日志记录会按照它们所描述的更新被请求的顺序定期写入Petal。(我们可以选择让日志记录同步写入。这提供了更好的故障语义，但增加了元数据操作的延迟。）。只有在日志记录<br>被写入Petal之后，服务器才会修改其固定位置中的实际元数据。Unix update demon会定期（大约每30秒）更新固定位置。</p><p>日志的大小是有限制的，在目前的实现中是128KB。考虑到Petal的分配策略，一个日志将由两个不同的物理磁盘上的两个64KB的片段组成。为每个日志分配的空间被作为一个循环缓冲区管理。当日志填满时，Frangipani会回收最旧的25%的日志空间，用于新的日志条目。通常情况下，回收区域的所有条目都是指已经写入Petal的元数据块（在之前的同步操作中），在这种情况下，不需要进行额外的Petal写入。如果有尚未写入的元数据块，这项工作将在日志被回收之前完成。考虑到日志的大小和Frangipani日志记录的典型大小（80-128字节），如果在两个周期性同步操作之间有大约1000-1600个修改元数据的操作，日志就会被填满。</p><p>如果一个Frangipani服务器崩溃了，系统最终会检测到失败，并在该服务器的日志上运行恢复。故障可能是由故障服务器的客户端检测到的，或者当锁服务要求故障服务器返回它所持有的锁而没有得到答复时。恢复守护进程被隐式的赋予失败服务器的日志和锁的所有权。该守护进程找到日志的开始和结束，然后按顺序检查每条记录，执行每一个尚未完成的描述性更新。在日志处理完成后，恢复进程释放其所有的锁并释放日志。然后，其他Frangipani服务器可以不受故障服务器的阻碍，故障服务器本身也可以选择重新启动（有一个空日志）。只要底层的Petal卷保持可用，系统就可以容忍无限数量的Frangipani服务器故障。</p><p>为了确保恢复能够找到日志的结尾（即使磁盘控制器不按顺序写入数据），我们在日志的每个512字节块上附加一个单调增加的日志序列号。通过找到一个低于前一个的序列号，可以可靠地检测到日志的结束。</p><p>Frangipani确保在有多个日志的情况下，日志和恢复工作正常。这需要注意几个细节。</p><p>首先，Frangipani的锁协议，在下一节中描述，确保不同服务器对相同数据的更新请求是序列化的。覆盖脏数据的写锁只有在脏数据被写入 Petal 之后才能更改所有者，可以是原始锁持有者写入，也可以是代表它运行的恢复进程写入。这意味着对于任何给定的块，最多只能有一个日志保存未完成的更新。</p><p>其次，Frangipani确保恢复只适用于自服务器获得覆盖它们的锁后所记录的更新，并且它仍然持有这些锁。这是为了确保锁协议所规定的序列化不被违反而需要的。我们通过强制执行一个更强的条件来实现这一保证：恢复绝不重复描述已经完成的更新的日志记录。为了实现后者，我们在每个512字节的元数据块上保留一个版本号。元数据如目录，它跨越了多个块，有多个版本号。对于日志记录所更新的每一个块，该记录包含了对更改的描述和新的版本号。在恢复过程中，只有当块的版本号小于记录的版本号时，才会应用对块的修改。</p><p>因为用户数据的更新没有被记录下来，只有元数据块有预留空间给版本号。这就产生了一个强制性的问题。如果一个块被用于元数据，被释放，然后又被重新用于用户数据，那么在版本号被错误的用户数据覆盖后，引用该块的旧日志记录可能不会被正确跳过。Frangipani通过重用释放的元数据块来保存新的元数据，从而避免了这个问题。</p><p>最后，Frangipani确保在任何时候只有一个恢复进程试图重放特定服务器的日志区域。锁服务通过授予活动的恢复进程对日志的独占锁来保证这一点。</p><p>Frangipani的记录和恢复方案假定，磁盘写入失败会使单个扇区的内容处于旧状态或新状态，但绝不会同时处于这两种状态。如果一个扇区被损坏，以至于读取它时出现CRC错误，Petal的内置复制通常可以恢复它。如果一个扇区的两个副本都丢失了，或者Frangipani的数据结构被软件错误破坏了，就需要一个元数据一致性检查和修复工具（像Unix fsck）。到目前为止，我们还没有实现这样的工具。</p><p>Frangipani的日志不是为了向用户提供高级别的语义保证。它的目的是提高元数据更新的性能，并通过避免每次服务器故障时运行fsck等程序来加速故障恢复。只有元数据被记录下来，而不是用户数据，所以用户不能保证在故障后文件系统的状态在他看来是一致的。我们并不声称这些语义是理想的，但它们与标准的本地Unix文件系统所提供的相同。在本地 Unix 文件系统和 Frangipani 中，用户可以通过在适当的检查点调用 fsync 来获得更好的一致性语义。</p><p>Frangipani的日志记录是应用了最早为数据库开发的技术[2]，后来被用于其他几个基于日志的文件系统[9, 11, 16, 18]。Frangipani不是一个日志结构的文件系统[32]；它不把所有的数据保存在日志中，而是维护传统的磁盘数据结构，用一个小的日志作为辅助，以提供更好的性能和故障原子性。与上述其他基于日志的文件系统不同，但与日志结构的文件系统Zebra[17]和xFS[1]一样，Frangipani保留多个日志。</p><h2><span id="5-同步和缓存的一致性">5 同步和缓存的一致性</span></h2><p>由于多个Frangipani服务器都在修改共享的磁盘数据结构，因此需要谨慎地进行同步，以便为每个服务器提供一致的数据视图，同时允许有足够的并发性，以便在负载增加或服务器增加时扩展性能。Frangipani使用多读/单写锁来实现必要的同步。当锁服务检测到冲突的锁请求时，会要求锁的当前持有者释放或降级以消除冲突。</p><p>一个读锁允许服务器从磁盘上读取相关数据并进行缓存。如果一个服务器被要求释放它的读锁，它必须在遵守之前使其缓存条目失效。写锁允许服务器读取或写入相关的数据并缓存它。服务器缓存的磁盘块副本只有在它持有相关的写锁时才能与磁盘上的版本不同。因此，如果一个服务器 被要求释放其写锁或将其降级为读锁，它必须在遵守之前将脏数据写到磁盘。如果是降级锁，它可以保留其缓存条目，但如果释放锁，则必须使其失效。</p><p>当写锁被释放或降级时，我们可以选择绕过磁盘，将脏数据直接转发给请求者，而不是将脏数据刷到磁盘。出于简单的原因，我们没有这样做。首先，在我们的设计中，Frangipani服务器不需要相互通信。它们只与Petal和锁服务器进行通信。其次，我们的设计确保当一个服务器崩溃时，我们只需要处理该服务器使用的日志。如果直接转发脏缓冲区，并且具有脏缓冲区的目标服务器崩溃，那么指向脏缓冲区的日志条目可能分布在多台机器上。这将给恢复和在日志空间填满时回收日志空间带来问题。</p><p>我们将磁盘上的结构分为逻辑段，并为每个段加锁。为了避免错误的共享，我们确保一个磁盘扇区不包含一个以上可以共享的数据结构。我们将磁盘上的数据结构划分为可上锁的段，旨在保持锁的数量合理地少，但又能避免普通情况下的锁争夺，从而使锁服务不成为系统的瓶颈。</p><p>因为日志是私有的，所以每个日志都是一个单独的可锁定段。位图空间也被划分为独占锁定的段，这样当分配新文件时就不会有争用。当前未分配给文件的数据块或索引节点受到分配位图段上的锁的保护，该段上的锁持有标记为空闲的位。最后，每个文件、目录或符号链接都是一个段;也就是说，一个锁同时保护inode和它所指向的任何文件数据。这种每个文件的锁粒度适合于很少并发写共享的工程工作负载。然而，其他工作负载可能需要更细粒度的锁定。</p><p>有些操作需要原子化的更新由不同锁覆盖的几个磁盘数据结构。我们通过对这些锁进行全局排序并在两个阶段获得这些锁来避免死锁。首先，一个服务器确定它需要什么锁。这可能涉及到获取和释放一些锁，例如在一个目录中查找名字。其次，它按照节点地址对锁进行排序，并依次获取每个锁。然后，服务器检查它在第一阶段检查的任何对象是否在其锁被释放时被修改。如果是的话，它就释放锁，并循环重复第一阶段。否则，它就执行操作，弄脏缓存中的一些块，并写一条日志记录。它保留每个锁，直到它覆盖的脏块被写回磁盘。</p><p>我们刚刚描述的缓存一致性协议与Echo[26]、Andrew文件系统[19]、DCE/DFS[21]和Sprite[30]中用于客户端文件缓存的协议相似。避免死锁的技术与Echo的类似。和Frangipani一样，Oracle数据库（Oracle Parallel Server），也是将脏数据写入磁盘，而不是在写入锁的后续所有者之间使用缓存到缓存的传输。</p><h2><span id="6-锁服务">6  锁服务</span></h2><p>Frangipani只需要其lock server的一小部分通用功能，而且我们不希望该服务在正常运行中成为性能瓶颈，因此许多不同的实现可以满足其要求。在Frangipani项目的过程中，我们已经使用了三种不同的lock server的实现，并且其他现有的lock server可以提供必要的功能，也许只需在上面加一层薄薄的代码。</p><p>lock server提供多读/单写锁。锁是粘性的；也就是说，一个客户端通常会保留一个锁，直到其他客户端需要一个冲突的锁。(回顾一下，锁服务的客户端是Frangipani服务器）。</p><p>锁定服务使用租约来处理客户端故障[15, 26]。当一个客户端第一次通讯lock server时，它获得了一个租约。客户端获得的所有锁都与租约相关。每个租约都有一个过期时间，目前设置为创建或最后一次更新后的30秒。客户端<br>必须在到期时间前更新其租约，否则服务会认为它已经失败。</p><p>网络故障可以阻止Frangipani服务器更新其租约，即使它没有崩溃。当这种情况发生时，服务器会丢弃它所有的锁和缓存中的数据。如果缓存中的任何东西是脏的，Frangipani会打开一个内部标志，使所有来自用户程序的后续请求返回一个错误。文件系统必须被卸载以清除这个错误状况。我们选择了这种激烈的报错方式，使它难以被无意中忽略。</p><p>我们最初的lock server实现是一个单一的、集中的服务器，它将所有的锁状态保存在易失性内存中。这样的服务器对Frangipani来说是足够的，因为Frangipani servers和他们的日志持有足够的状态信息，即使锁服务在崩溃中失去了所有的状态，也可以恢复。然而，锁服务的失败将导致一个巨大的性能故障。</p><p>我们的第二个实施方案将锁的状态存储在Petal虚拟磁盘上，在返回客户端之前，将每个锁的状态变化写到Petal上。如果主lock server崩溃了，备份服务器将从Petal中读取当前状态并接管，以提供持续服务。有了这个方案，故障恢复更加透明，但普通情况下的性能比集中式的内存方法要差。在进入下一个实施方案之前，我们没有完全实现对所有故障模式的自动恢复。</p><p>我们的第三个也是最后一个锁服务实现是完全分布式的，用于容错和可扩展的性能。它由一组相互合作的锁服务器和一个连接到每个Frangipani服务器的办事员模块组成。</p><p>锁服务将锁组织成由ASCII字符串命名的表。表内的各个锁是由64位整数命名的。回顾一下，一个Frangipani文件系统只使用一个Petal虚拟磁盘，尽管多个Frangipani文件系统可以安装在同一台机器上。每个文件系统都有一个与之相关的表。当一个Frangipani文件系统被挂载时，Frangipani服务器调用clerk，打开与该文件系统相关的锁表。锁服务器在成功打开时给clerk一个租赁标识符，这个标识符被用于他们之间所有的次序通信。当文件系统被卸载时，clerk关闭锁表。(<code>clerk翻译应该有点问题，我理解的客户端</code>)</p><p>客户端和锁服务器通过异步消息而不是RPC进行通信，以尽量减少内存的使用量，并实现良好的灵活性和性能。对锁进行操作的基本消息类型是请求、授予、撤销和释放。请求和释放消息类型是由客户端发送给锁服务器的，而授予和撤销消息类型是由锁服务器发送给客户端的。锁的升级和降级操作也是使用这四种消息类型处理的。</p><p>锁服务使用一个容错的分布式故障检测机制来检测锁服务器的崩溃。这与Petal使用的机制相同。它是基于各组服务器之间及时交换心跳信息。它使用多数共识来容忍网络分区。</p><p>锁在服务器和每个clerk那里都要消耗内存。在我们目前的实现中，服务器为每个锁分配了112个字节的块，此外还有104个字节给每个有未决或已批准的锁请求的clerk。每个客户端每个锁占用232字节。为了避免因为粘性锁而消耗过多的内存，clerk 会丢弃那些长时间（1小时）没有使用的锁。</p><p>使用Lamport的Paxos算法[23]，在所有锁服务器上持续复制少量不经常变化的全局状态信息。锁服务重复使用最初为Petal编写的Paxos的实现。全局状态信息包括一个锁服务器的列表，每个服务器负责服务的锁的列表，以及已经打开但尚未关闭每个锁表的clerk的列表。这些信息被用来达成共识，在锁服务器之间重新分配锁，在锁服务器崩溃后从clerk那里恢复锁状态，并促进Frangipani服务器的恢复。为了提高效率，锁被划分为大约一百个不同的锁组，并按组分配给服务器，而不是单独分配。</p><p>锁偶尔会在不同的锁服务器之间重新分配，以弥补一个崩溃的锁服务器或利用一个新恢复的锁服务器。当一个锁服务器被永久地添加到系统中或从系统中移除时，也会发生类似的重新分配。在这种情况下，锁总是被重新分配，以便每个服务器提供的锁的数量是平衡的，重新分配的数量是最小的，并且每个锁正好由一个锁服务器提供。重新分配分两个阶段进行。在第一阶段，失去锁的锁服务器从其内部状态中丢弃这些锁。在第二阶段，获得锁的锁服务器与打开相关锁表的办事员联系。这些服务器从clerk那里恢复其新锁的状态，而clerk则被告知其锁的新服务器。</p><p>当Frangipani服务器崩溃时，在执行适当的恢复操作之前，无法释放其拥有的锁。具体来说，必须处理崩溃的Frangipani服务器的日志，并且必须将任何挂起的更新写入Petal。当Frangipani服务器的租约到期时，锁服务将要求另一台Frangipani机器上的clerk执行恢复，然后重新租用属于崩溃的Frangipani服务器的所有锁。该clerk被授予一个锁，以确保以独占方式访问日志。此锁本身由租约覆盖，因此如果此恢复过程失败，锁服务将启动另一个恢复过程。</p><p>一般来说，Frangipani系统可以容忍网络分区，在可能的情况下继续运行，否则会麻利的关闭。具体来说，Petal可以在网络分区的情况下继续运行，只要大多数Petal服务器保持正常并处于通信状态，但如果大多数分区中没有副本，Petal虚拟磁盘的部分将无法访问。只要大多数锁服务器保持正常并处于通信状态，锁服务就会继续运行。如果一个Frangipani服务器被分区离开了锁服务，它将无法续租。锁服务将宣布这样的Frangipani服务器死亡，并从它在Petal上的日志开始恢复。如果一个Frangipani服务器被脑裂无法访问Petal，它将无法读取或写入虚拟磁盘。在这两种情况下，服务器将不允许用户进一步访问受影响的文件系统，直到脑裂恢复和文件系统被重新挂载。</p><p>当Frangipani server的租约过期时，有一个小的危险。如果服务器没有真正崩溃，而只是由于网络问题与锁服务失去联系，它可能在租约过期后仍然试图访问Petal。Frangipani服务器会检查它的租约是否仍然有效（并且在一定的时间内仍然有效），在失效之前依然试图对Petal进行写入。然而，当写请求到达时，Petal不做任何检查。因此，如果在Frangipani的租约检查和随后的写请求到达Petal之间有足够的时间延迟，我们可能会有一个问题：租约可能已经过期，锁已经给了另一个服务器。我们使用了足够大的误差范围（15秒），在正常情况下，这个问题不会发生，但我们不能绝对排除它。</p><p>在未来，我们希望能消除这种危险；一种可行的方法是如下。我们在每个写给Petal的请求上添加一个到期时间戳。时间戳设置为生成写请求时的当前租约到期时间，减去锁延时删除的时间。然后我们让Petal忽略任何时间戳小于当前时间的写请求。只要Petal和Frangipani服务器上的时钟同步在差值范围内，这种方法就能可靠地拒绝租约过期的写入。</p><p>另一种不需要同步时钟的方法是将锁服务器与Petal集成，并将从锁服务器获得的租约标识符包含在每个对Petal的写入请求中。然后，Petal将拒绝任何具有过期租约标识符的写入请求。</p><h2><span id="7-添加和删除服务器">7 添加和删除服务器</span></h2><p>随着Frangipani安装的增长和变化，系统管理员偶尔会需要增加或删除服务器机器。Frangipani的设计使这项任务变得简单。</p><p>在一个正在运行的系统中添加另一个Frangipani服务器，只需要少量的管理工作。新的服务器只需要被告知使用哪个Petal虚拟磁盘和在哪里找到锁服务。新的服务器与锁服务通讯以获得租约，从租约标识符中确定使用哪一部分日志空间，然后开始运行。管理员不需要接触其他服务器；它们会自动适应新服务器的存在。</p><p>移除Frangipani服务器甚至更容易。简单地关闭服务器就可以了。服务器最好刷新所有脏数据并在停止前释放其锁，但这并不是严格的需要。如果服务器突然停止，在下次启动时，它先获取一个锁，然后在它的日志上运行恢复程序，使共享磁盘进入一个一致的状态。同样，管理员不需要接触其他服务器。</p><p>Petal服务器也可以透明地添加和删除，如Petal论文[24]中所述。锁定服务器的添加和删除方式类似。</p><h2><span id="8-备份">8 备份</span></h2><p>Petal的快照功能为我们提供了一种方便的方式，使Frangipani文件系统的完整转储一致。Petal允许客户在任何时间点创建一个虚拟磁盘的精确拷贝。快照副本与普通虚拟磁盘相同，只是无法修改。为了提高效率，该实现使用了写时拷贝技术。快照是崩溃一致的；也就是说，快照反映了一种一致的状态，如果所有Frangipani服务器崩溃，Petal虚拟磁盘可能会处于这种状态。</p><p>因此，我们可以简单地通过提取Petal快照并复制到磁带上来备份一个Frangipani文件系统。该快照将包括所有的日志，因此可以通过将其恢复到新的Petal虚拟磁盘，并在每个日志上运行恢复功能来恢复它。由于崩溃的一致性，从快照中恢复与从整个系统的电源故障中恢复的问题相同。</p><p>我们可以通过对Frangipani的一个小改动来改进这个方案，创建在文件系统层面上一致的快照，并且不需要恢复。我们可以通过让备份程序强制所有的Frangipani服务器进入一个屏障来实现这一目标，该屏障使用一个由锁服务提供的普通全局锁。Frangipani服务器以共享模式获得这个锁，以进行任何修改操作，而备份程序则以独占模式请求它。当Frangipani服务器收到释放屏障锁的请求时，它通过阻止所有修改数据的新文件系统调用进入屏障，清理其缓存中的所有脏数据，然后释放该锁。当所有的Frangipani服务器都进入屏障时，备份程序能够获得最终锁；然后，它创建一个Petal快照并释放锁。此时，服务器以共享模式重新获取锁，并恢复正常操作。</p><p>使用后一种方案，新快照可以作为Frangipani卷装载，而无需恢复。新卷可以在线访问以检索单个文件，也可以以传统备份格式转储到磁带上，而不需要Frangipani进行恢复。但是，新卷必须以只读方式装载，因为Petal快照当前是只读的。将来，我们可能会扩展Petal以支持可写快照，或者在Petal上实现一个分层来模拟它们。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;frangipani-一个可伸缩的分布式文件系统&quot;&gt;Frangipani: 一个可伸缩的分布式文件系统&lt;/span&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;span id=&quot;摘要&quot;&gt;摘要&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;理想的分布式文件系统应该为所有用户提供对同一组文件的</summary>
      
    
    
    
    <category term="分布式服务" scheme="chunlife.top/categories/分布式服务/"/>
    
    
    <category term="论文" scheme="chunlife.top/tags/论文/"/>
    
    <category term="A Scalable Distributed File System" scheme="chunlife.top/tags/A-Scalable-Distributed-File-System/"/>
    
  </entry>
  
  <entry>
    <title>Amazon Aurora以及ZK论文学习</title>
    <link href="chunlife.top/2022/01/02/Amazon-Aurora%E4%BB%A5%E5%8F%8AZK%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"/>
    <id>chunlife.top/2022/01/02/Amazon-Aurora%E4%BB%A5%E5%8F%8AZK%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-01-02T15:00:12.000Z</published>
    <updated>2022-05-04T04:40:35.063Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="论文理解">论文理解</span></h3><p>ZK的论文里面的东西感觉很多都是和ETCD相似的，之前也写过ZK的一些不同的点，原理上，毕竟其也是基于raft协议的，操作上相似感觉比较合理。</p><p>Aurora，这里面还是有很多东西的，不管是基于MySQL的改造（canal搬运log感觉很像），另外还有quorum因地制宜的使用，数据库服务与存储层服务的分层设计，简化副本复制，采用链式复制等，对这种大型服务的设计能力可见一斑。</p><p><img src="v2-8aa123d892340535ea3604e5bf4bfa49_720w.jpg" alt="论文总结"></p><h2><span id="资料">资料</span></h2><p>思维导图文件：</p><p><a href="https://pan.baidu.com/link/zhihu/79hWzOuMhjikTJ1ER3Xw1XZmQCW0JESwdsBT==" target="_blank" rel="noopener">https://pan.baidu.com/link/zhihu/79hWzOuMhjikTJ1ER3Xw1XZmQCW0JESwdsBT==</a></p><p><em>思维导图中有很多链接，以及我附带的一些文章附件，用于帮助理解。</em></p><p>论文翻译的地址：</p><p><a href="https://iswade.github.io/translate/zookeeper/" target="_blank" rel="noopener">Zookeeper论文翻译 - iswade’s blog</a></p><p><a href="https://xie.infoq.cn/article/09849d56c3b18064af6c7f857" target="_blank" rel="noopener">【译】Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases 上篇</a><a href="https://link.zhihu.com/?target=https%3A//xie.infoq.cn/article/09849d56c3b18064af6c7f857" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//xie.infoq.cn/article/09849d56c3b18064af6c7f857</a>)</p><h2><span id="mysql-binlog的理解">Mysql binlog的理解</span></h2><p>只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo     log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”( a1 — &gt; a2 )；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。</p><p><strong>图中浅色框表示是在</strong>innodb<strong>内部执行的，深色框表示是在执行器中执行的。</strong></p><p><img src="image-20220102230621250.png" alt="MySQL执行流程"></p><p>两阶段提交是指redo log类似于事务写日志的方式，只有在确认binlog 被实际落盘时，才会出现提交redo log的情况。</p><p><strong>分阶段失败</strong></p><p><strong>1 prepare阶段  2 写binlog  3 commit</strong></p><p>当在2之前崩溃时</p><p>重启恢复：后发现没有commit，回滚。  备份恢复：没有binlog 。</p><p>结果：一致</p><p>当在3之前崩溃</p><p>重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。</p><p>备份：有binlog。</p><p>结果： 一致</p><blockquote><p>binlog用于备份，redolog则保证binlog的正确性，提供crash-safe能力，redo log循环写，不持久保存，binlog则进行“归档”。</p></blockquote><p>MySQL中<strong>undo</strong>的内容会被记录到redo中吗？会的</p><p>比如一个事务在执行到一半的时候实例崩溃了，在恢复的时候先恢复redo，再根据redo构造undo回滚宕机前没有提交的事务</p><p>数据被修改一般会积累再内存中(如图上)，累积一段后再刷入磁盘，如果这个时候崩溃，也不会出现什么问题，重启时会扫描binlog，没有写入磁盘的数据也会在此时被写入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;论文理解&quot;&gt;论文理解&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;ZK的论文里面的东西感觉很多都是和ETCD相似的，之前也写过ZK的一些不同的点，原理上，毕竟其也是基于raft协议的，操作上相似感觉比较合理。&lt;/p&gt;
&lt;p&gt;Aurora，这里面还是有很多东西的，不管</summary>
      
    
    
    
    <category term="分布式服务" scheme="chunlife.top/categories/分布式服务/"/>
    
    
    <category term="MIT 6.824" scheme="chunlife.top/tags/MIT-6-824/"/>
    
    <category term="论文" scheme="chunlife.top/tags/论文/"/>
    
  </entry>
  
</feed>
