[{"title":"组件与语言特性的学习","date":"2018-08-26T03:03:53.000Z","path":"2018/08/26/组件与语言特性的学习/","content":"<h1 id=\"sync-Map\"><a href=\"#sync-Map\" class=\"headerlink\" title=\"sync.Map\"></a>sync.Map</h1><p>这是一种线程安全的map用法，在版本1.9时出现，按照以前的用法，多协程情况下，需要使用将map和锁一起使用才可以做到线程安全，而现在可直接使用该类型。</p>\n<p>以下内容取自<a href=\"https://blog.csdn.net/champly/article/details/77622328\" target=\"_blank\" rel=\"noopener\">Go1.9 安全map用法</a>。</p>\n<p><img src=\"1535253147536.png\" alt=\"1535253147536\"></p>\n<h1 id=\"Gin框架\"><a href=\"#Gin框架\" class=\"headerlink\" title=\"Gin框架\"></a>Gin框架</h1><p>encoding/json 貌似不支持required json tag，实际验证好像也不支持，这个字段表示传递的json数据没有这个字段就会报错。</p>\n<p>GIN框架补充了这个字段，使用binding tag，如果没有该字段，直接报错。</p>\n<p><img src=\"clip_image001.png\" alt=\"img\"></p>\n<p>c.BindQuery可以直接把Query映射出来，当然可以操作form表单的数据，操作及其方便，涉及到反射操作，还有检查的时间。</p>\n<h1 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a>文件下载</h1><p>指定浏览器直接下载文件，且使用文件下载原名，其不进行打开操作。</p>\n<p><a href=\"https://segmentfault.com/q/1010000000692593\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000000692593</a></p>\n<p><a href=\"https://golangtc.com/t/54d9ca47421aa9170200000f\" target=\"_blank\" rel=\"noopener\">https://golangtc.com/t/54d9ca47421aa9170200000f</a></p>\n<p><img src=\"clip_image002.png\" alt=\"指定下载文件名\"></p>\n<p>golang filepath.Ext  获取文件后缀名 </p>\n<h1 id=\"时间戳格式变换为YYYYMMDD\"><a href=\"#时间戳格式变换为YYYYMMDD\" class=\"headerlink\" title=\"时间戳格式变换为YYYYMMDD\"></a>时间戳格式变换为YYYYMMDD</h1><p>//返回现在时间</p>\n<p>tNow:=time.Now()</p>\n<p>//时间转化为string，layout必须为”2006-01-0215:04:05”</p>\n<p>timeNow:=tNow.Format(“20060102”)</p>\n<p>fmt.Println(“tNow(timeformat):”,tNow)</p>\n<p>fmt.Println(“tNow(stringformat):”,timeNow)</p>\n","categories":[{"name":"项目","slug":"项目","permalink":"chunlife.top/categories/项目/"}],"tags":[{"name":"学习","slug":"学习","permalink":"chunlife.top/tags/学习/"}]},{"title":"EE小白到CS小白","date":"2018-08-12T09:50:22.000Z","path":"2018/08/12/EE小白到CS小白/","content":"<p>从武汉来到深圳，怀揣着一个傲娇的想法走出来，纯粹就是想要看看世界，毕业呆了四年的城市毕竟太过熟悉了。同时，之前做的是嵌入式开发，在公司当个软件组长太过安逸，而且在武汉工资和前景感觉都不是太好看，于是在毕业又做了大半年后，于公司辞职后，来到了深圳。</p>\n<a id=\"more\"></a>\n<h2 id=\"五一\"><a href=\"#五一\" class=\"headerlink\" title=\"五一\"></a>五一</h2><p>五月一号到的深圳，听着《飞得更高》，一路忐忑。</p>\n<p>一个陌生的城市，感受当然是深圳各个方面都是666，什么都是新样式。（实际感受和武汉没有啥一样）</p>\n<p>到深圳肯定是先叫同学一顿约约约，过个五一再说，然后就是忙碌的面试过程了。</p>\n<p>工作基本方向都是嵌入式，因为自己之前就是从事的嵌入式军工行业，对Linux、VxWorks比较熟悉，找工作当然也是跟这方面息息相关的，工资普遍会比在武汉高出一个3-4K的额度，对于我这样毕业一年的人，主要还是想定一个好点的行业与公司好好的发展发展，这样手上才有个屠龙技。非常感谢面试的那些公司，对我都比较友善，知道我刚来深圳，有的面试官在面试完后还会告诉我一些</p>\n<p>在第三天的时候面了一家做存储的公司，面的是嵌入式软件工程师，安排职位时是给的Go开发（后端开发）岗位，面试得比较愉快，当时手里已经拿了有几份offer了，所以对工作会有点自己的考虑。</p>\n<p>嵌入式对于我肯定是熟悉一点，在大学里，实习，工作所做的都是嵌入式开发，我也自学了Android开发，找的工作也有对Android方向的，这个方向的嵌入式虽没有互联网一些热门方向霸道，但不会太差，现在手里工作的offer工资也很好看。</p>\n<p>后端的职位，是使用Go开发，对比Java来说，足够小众，所做的内容我也可以说出其各种不好，但换个角度，我将其视作一个机会，一个我尝试的机会，在做嵌入式时，已经听闻很多CS方面的事了，单纯的，我想过去看看，可能不成功，大不了我就滚回去做嵌入式就可以了，谁还不允许我犯错了。</p>\n<p>心理足够忐忑，即使到了现在还是那么忐忑，想想这个决定可能对我的影响，中间还有大华的邀约，现在想来做出这个决定依然是很刺激的。</p>\n<h2 id=\"五一前\"><a href=\"#五一前\" class=\"headerlink\" title=\"五一前\"></a>五一前</h2><p>在武汉，出学校后，自己就不断的懈怠了，并没有在学校那种冲劲，对自己的发展比较迷茫，不知道路在哪里。</p>\n<p>之前是在一家做军工产品的公司工作，做的也是比较安逸，算是平静的发展吧。但我自己逐渐不太满足，因为我对自己的要求在逐渐下降，这让我自己很苦恼，我标准应该是一直提高啊。</p>\n<p>对于出去，我就想着出去走走，见见世面嘛，外面不见得会有多好，但没在外面待一段时间，哪里来的深刻对比呢？所以，还是出来走走比较靠谱。</p>\n<h2 id=\"如今\"><a href=\"#如今\" class=\"headerlink\" title=\"如今\"></a>如今</h2><p>对于两个方向，我都是个小白，嵌入式工作了两年，后端才刚开始，小白摸着石头过个河，路上见见更多的前辈恩师，还有更多的风景，求个快活。</p>\n<p>现在，我也是迷茫的，但我知道自己还是向前的，对自己是要求的。毕竟我还有追求。</p>\n<p>我追求嘛，谁都需要，谁都可以去实现。毕竟有一句话是，和尚摸得，我摸不得？</p>\n<p>哈哈，不怎么应景。</p>\n","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"chunlife.top/tags/随笔/"}]},{"title":"比特币—-挖矿","date":"2018-08-11T14:42:02.000Z","path":"2018/08/11/比特币—-挖矿/","content":"<p>以前做嵌入式智能感叹比特币价格的疯狂，曾突破到一万多美元一枚的价格，让我流下了没有技术的泪水，现在却是可以理解理解到底啥玩意叫个区块链，啥叫个比特币了。</p>\n<a id=\"more\"></a>\n<h1 id=\"区块链与比特币\"><a href=\"#区块链与比特币\" class=\"headerlink\" title=\"区块链与比特币\"></a>区块链与比特币</h1><p>区块链可以说是类比特币技术的一个大的集合，囊括了其一个整体的技术演变而来，并不与比特币相等同。</p>\n<p>比特币的出现很多地方应该是吸收了很多“密码朋克”这个组织的很多成果，对于这个组织里面的人，我只能表示佩服，很了不起。2008年中本聪发表的比特币白皮书——《比特币：一个点对点的电子现金系统》，其提出的去中心化思想确实厉害，更应该让我感到佩服的是，这个东西不仅仅是一个白皮书一样的存在，它让这个思想具象化了。</p>\n<h2 id=\"比特币\"><a href=\"#比特币\" class=\"headerlink\" title=\"比特币\"></a>比特币</h2><p>比特币是一种数字货币。</p>\n<p>当我们共同承认它具有价值时，它就具有了购买力。举个例子：RMB是国家给予其价值，那么其就被赋予了价值，那数字货币也一样。</p>\n<h3 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h3><p>比特币使用Hash进行校验，使用Hash对内容进行Hash计算，得出Hash值，拿这个值进行内容校验。</p>\n<p><img src=\"1534000072795.png\" alt=\"1534000072795\"></p>\n<p>拿以后的区块，会将前一个Hash值与当前内容一起进行Hash计算，得到一个现在区块持有的Hash值。</p>\n<p><img src=\"1534000007496.png\" alt=\"1534000007496\"></p>\n<p>区块不断在累加，逐渐累积成链。我们若是需要验证区块，那么只需要抽取链最后一个区块Hash进行校验即可。</p>\n<p><img src=\"1533999959460.png\" alt=\"1533999959460\"></p>\n<h3 id=\"账户所有权\"><a href=\"#账户所有权\" class=\"headerlink\" title=\"账户所有权\"></a>账户所有权</h3><p>比特币很安全，安全的原因是分布式账本上没有存储任何个人信息，交易信息的对接使用的是“地址”（账号），也就是地址对地址间的通信，那地址是什么呢？</p>\n<p>一个“地址”对应于一个私钥，私钥是唯一的，其不可重置。地址与私钥为非对称关系，也就是说私钥可进行两次Hash计算后得到地址，而地址是不可进行逆推的（可查看RSA加密解密）。</p>\n<p><img src=\"1534000622004.png\" alt=\"1534000622004\"></p>\n<p>利用非对称密钥，公钥是开放出去的，验证私钥的过程既是使用公钥验证的过程。</p>\n<p><img src=\"1534061724465.png\" alt=\"1534061724465\"></p>\n<p>然后将个交易记录广播给其他节点，由其他节点去验证信息的正确。</p>\n<h3 id=\"挖矿\"><a href=\"#挖矿\" class=\"headerlink\" title=\"挖矿\"></a>挖矿</h3><p>挖矿的过程既是记账的过程，记账需要提供算力，使用Hash算法打包记录，而比特币作为记账的奖励分发给用户。</p>\n","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"chunlife.top/tags/区块链/"},{"name":"比特币","slug":"比特币","permalink":"chunlife.top/tags/比特币/"}]},{"title":"RSA加密解密","date":"2018-07-29T13:43:46.000Z","path":"2018/07/29/RSA加密解密/","content":"<p>因为项目需要，最近做一个RSA加密解密的接口，使用Go进行开发，接口使用jsonrpc，go 对RSA加密解密有很好的支持，不过由于受限于底层单片机，所以上层应用需要做一些稍微的调整。</p>\n<a id=\"more\"></a>\n<h2 id=\"一、概要\"><a href=\"#一、概要\" class=\"headerlink\" title=\"一、概要\"></a>一、概要</h2><p>RSA是一种非对称加密算法，什么是非对称加密算法呢，那就是公钥、私钥可互相进行加密解密：公钥加密—私钥解密，私钥加密—公钥解密。 </p>\n<p>了解RSA算法的实现原理，可参考：<a href=\"https://www.cnblogs.com/fangxupeng/p/4128990.html\" target=\"_blank\" rel=\"noopener\">非对称加密过程详解（基于RSA非对称加密算法实现）</a></p>\n<h2 id=\"三、RSA一些名词的解释\"><a href=\"#三、RSA一些名词的解释\" class=\"headerlink\" title=\"三、RSA一些名词的解释\"></a>三、RSA一些名词的解释</h2><p>什么是PKCS#1，PKCS（公钥密码标准），而#1就是RSA的标准。 </p>\n<p>PEM文件，也就是公私钥的编码格式。</p>\n<p>RSA算法的原理：<a href=\"https://blog.csdn.net/starryheavens/article/details/8536238\" target=\"_blank\" rel=\"noopener\">RSA算法详解</a>，从这篇博客主要是提取出RSA算法的公式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C=(P^e)%n</span><br></pre></td></tr></table></figure>\n<p>N是公钥私钥共同使用的，其为模数。另外还有公钥的指数E，私钥的指数E。</p>\n<p>公钥的指数一般是65537，私钥的指数则是一个极大的数，想想一个极大的数作为指数，计算时间是会耗费很长时间的。故公钥加密解密都很快，私钥则会慢很多 </p>\n<h2 id=\"二、Go中的RSA加密解密\"><a href=\"#二、Go中的RSA加密解密\" class=\"headerlink\" title=\"二、Go中的RSA加密解密\"></a>二、Go中的RSA加密解密</h2><p>RSA标准是通过公钥加密，私钥解密 ，没有私钥加密，公钥解密。为什么会这样呢？</p>\n<p>Go设计库一般会严格按照标准来进行设计（在很多地方都见过相似做法），那是RSA标准中没有后一种情况的使用场景吗？其实是有的，只不过这个过程不要加密解密，而是RSA签名与验签。所以按照标准，RSA标准库也就不会有私钥加密，公钥解密的方法了。</p>\n<p>这个问题想想应该是很多人的问题了，那么在Google上进行搜索了下，还是发现了解决方法。</p>\n<p><a href=\"https://github.com/wenzhenxi/gorsa\" target=\"_blank\" rel=\"noopener\">https://github.com/wenzhenxi/gorsa</a></p>\n<p>库中实现了公钥加解密的方法。</p>\n<p>还有其他解决方法吗？是有的，在Google上进行搜索就可以找到，记得还有人使用CGO调用C库来解决。</p>\n<h2 id=\"四、Go-RSA库的使用\"><a href=\"#四、Go-RSA库的使用\" class=\"headerlink\" title=\"四、Go RSA库的使用\"></a>四、Go RSA库的使用</h2><p>标准库的使用者很多，博客也很多，这里不做多的介绍，放上一个博主的链接。</p>\n<p><a href=\"http://blog.studygolang.com/2013/01/go%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E4%B9%8Brsa/\" target=\"_blank\" rel=\"noopener\">GO加密解密之RSA</a></p>\n<h2 id=\"五、项目中的问题\"><a href=\"#五、项目中的问题\" class=\"headerlink\" title=\"五、项目中的问题\"></a>五、项目中的问题</h2><p>此处，由于我的问题比较特殊，所以到此并没完全解决我的问题，还记得上面说的RSA指数与模数的东西吗，因为上层是与stm32进行通信，32RSA的库是需要自己手动将指数与模数填入结构体中的，那么上层就应该将生成的私钥进行分解开来，得到stm32所需要的指数和模数，那么怎么得到这些数据呢。</p>\n<p>我使用的方法是借用OpenSSL，理论上来说像Python就可以做到，但是我并不想将事情复杂化，直接借用现有的工具是最省事的。</p>\n<p>参考：<a href=\"https://blog.csdn.net/junkie0901/article/details/40539857\" target=\"_blank\" rel=\"noopener\">如何用 openssl 生成RSA双密匙；签名证书；加密文件邮件</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in private.pem -text -noout</span><br></pre></td></tr></table></figure>\n<p>-noout : 表示不显示密钥</p>\n<p>运行结果：</p>\n<p><img src=\"1533047035026.png\" alt=\"1533047035026\"></p>\n<p>modulus、publicExponent、privateExponent，这三个数就是我们所需要的数据（publicExponent一般算法会设为65537）。</p>\n<p>那么此处就很简单的进行字符串截取就可以做到拿出这三个数据了。</p>\n<h2 id=\"六、AES加密解密\"><a href=\"#六、AES加密解密\" class=\"headerlink\" title=\"六、AES加密解密\"></a>六、AES加密解密</h2><p>既然提到了RSA，不对称加密算法了，那么也去了解了解AES对称加密算法吧。</p>\n<p><a href=\"https://blog.csdn.net/yue7603835/article/details/73395580\" target=\"_blank\" rel=\"noopener\">golang实现AES ECB模式的加密和解密</a></p>\n<p>Go的实现可参考贴出来的链接，不过此处给出我遇到的一个问题。</p>\n<p>截取自博客中的原文：</p>\n<p><img src=\"1533047635959.png\" alt=\"1533047635959\"></p>\n<p>标记出来的话，其实是有问题的，AES算法，区块长度是固定的，为128bit。</p>\n<p>摘抄自<a href=\"https://baike.baidu.com/item/aes/5903?fr=aladdin\" target=\"_blank\" rel=\"noopener\">百度百科</a>：严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中二者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128比特，密钥长度则可以是128、192、256比特；而Rijndael使用的密钥和区块长度可以是32位的整数倍，以128位为下限，256比特为上限。加密过程中使用的密钥是由Rijndael密钥生成方案产生。</p>\n<p>在golang的源码设计中也可以证明这点，其blocksize设定为const，其值为16(byte)，显然，标准库是并不允许使用者去修改这个值的，那么AES-128/192/256，其实是针对的密钥长度来说的。</p>\n<p>另外，使用go AES库需要注意的是，go aes输入的密钥不满足16、24、32的要求，会直接返回错误，其并没有设计补全机制，需要自己实现。</p>\n<p>数据块长度不足128bit，其同样也需要补全；很遗憾的是go依然没有帮助自动补全。补全方式有多种，一般常见的是zeropadding，pkcs5padding，pkcs7padding。 </p>\n<p>参考<a href=\"https://studygolang.com/articles/6662\" target=\"_blank\" rel=\"noopener\">golang AES/ECB/PKCS5 加密解密 url-safe-base64</a></p>\n<p>博客使用的是pkcs5padding，这里补上zeropadding。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ZeroPadding</span><span class=\"params\">(ciphertext []<span class=\"keyword\">byte</span>, blockSize <span class=\"keyword\">int</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">\tpadding := blockSize - <span class=\"built_in\">len</span>(ciphertext)%blockSize</span><br><span class=\"line\">\tpadtext := bytes.Repeat([]<span class=\"keyword\">byte</span>&#123;<span class=\"number\">0</span>&#125;, padding) </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">append</span>(ciphertext, padtext...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ZeroUnPadding</span><span class=\"params\">(origData []<span class=\"keyword\">byte</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bytes.TrimFunc(origData,</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> r == <span class=\"keyword\">rune</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附上我写的填充key的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">KeyPadding</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(keyByte []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tkeyLen := <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> keyLen &lt; <span class=\"number\">16</span>:</span><br><span class=\"line\">\t\tkeyByte = ZeroPadding([]<span class=\"keyword\">byte</span>(key), <span class=\"number\">16</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> keyLen &gt; <span class=\"number\">16</span> &amp;&amp; keyLen &lt; <span class=\"number\">24</span>:</span><br><span class=\"line\">\t\tkeyByte = ZeroPadding([]<span class=\"keyword\">byte</span>(key), <span class=\"number\">24</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> keyLen &gt; <span class=\"number\">24</span> &amp;&amp; keyLen &lt; <span class=\"number\">32</span>:</span><br><span class=\"line\">\t\tkeyByte = ZeroPadding([]<span class=\"keyword\">byte</span>(key), <span class=\"number\">32</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> keyLen &gt; <span class=\"number\">32</span>:</span><br><span class=\"line\">\t\tkeyByte = []<span class=\"keyword\">byte</span>(key)[:<span class=\"number\">32</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tkeyByte = []<span class=\"keyword\">byte</span>(key)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> keyByte</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"七、使用的方法\"><a href=\"#七、使用的方法\" class=\"headerlink\" title=\"七、使用的方法\"></a>七、使用的方法</h2><h3 id=\"bytes-Join将byte数组的数组进行组合\"><a href=\"#bytes-Join将byte数组的数组进行组合\" class=\"headerlink\" title=\"bytes.Join将byte数组的数组进行组合\"></a>bytes.Join将byte数组的数组进行组合</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bytes.Join(pBytes, []<span class=\"keyword\">byte</span>(<span class=\"string\">\"\"</span>))</span><br></pre></td></tr></table></figure>\n<p>第二个参数表示数组间用什么去间隔</p>\n<h3 id=\"将一个大数按大小端转换为byte数组模式\"><a href=\"#将一个大数按大小端转换为byte数组模式\" class=\"headerlink\" title=\"将一个大数按大小端转换为byte数组模式\"></a>将一个大数按大小端转换为byte数组模式</h3><p>binary.BigEndian.PutUint64</p>\n<p><a href=\"https://blog.csdn.net/coledaddy/article/details/71195528\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/coledaddy/article/details/71195528</a> </p>\n<h3 id=\"返回子串在字符串中的索引\"><a href=\"#返回子串在字符串中的索引\" class=\"headerlink\" title=\"返回子串在字符串中的索引\"></a>返回子串在字符串中的索引</h3><p>例如strings.Index(str, “modules”)，返回的是开始出现”modules”的位置，即”m”。</p>\n<h3 id=\"将数组转换为以“-”分割的字符串\"><a href=\"#将数组转换为以“-”分割的字符串\" class=\"headerlink\" title=\"将数组转换为以“,”分割的字符串\"></a>将数组转换为以“,”分割的字符串</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Replace(strings.Trim(fmt.Sprint(byteArr),<span class=\"string\">\"[]\"</span>), <span class=\"string\">\" \"</span>, <span class=\"string\">\",\"</span>, <span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"将十六进制的字符，转换为整数\"><a href=\"#将十六进制的字符，转换为整数\" class=\"headerlink\" title=\"将十六进制的字符，转换为整数\"></a>将十六进制的字符，转换为整数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strconv.ParseUint(data, 16, 8)</span><br></pre></td></tr></table></figure>\n<p>data：字符，16：进制，8：转换数据的大小，8则是8bit。</p>\n<h2 id=\"2018年8月22日17-38-32\"><a href=\"#2018年8月22日17-38-32\" class=\"headerlink\" title=\"2018年8月22日17:38:32\"></a>2018年8月22日17:38:32</h2><p>本来以为rsa加密解密的事都要翻篇了，谁知道底层突然和我说交互出了问题，STM32使用的RSA是官方库，Go使用的是官方库，理论上不应该有什么问题的，但实际上就是出了问题。</p>\n<p>问题是这样的，Go使用私钥加密，STM32无法使用公钥进行解密；STM32使用私钥加密，Go无法进行公钥解密。但双方公钥加密，对方都可以进行私钥解密。</p>\n<p>然后花了一天的时间的去细细的琢磨这个事，觉得这个过程还是很有意思的。</p>\n<p>首先，则是两方都去检查源码是否出现使用错误，在互相review代码确认无误，这样不会造成总是去怀疑对方的代码，至少在使用上都是按照官方文档进行的操作。</p>\n<p>第二步，再三确认私钥加密，公钥解密这个种非标用法是可行的。因为RSA签名和验证过程是包含有私钥加密，公钥解密的，这个点是不需要再去考虑正确性的。</p>\n<p>第三步，双方通讯无法通过对方，那么很自然的就会想到，先抛弃掉对方，使用另外一种标准库，或者是语言的标准库来佐证自己的库的正确性，这里我选择的是使用OpenSSL的接口，使用CGo，调用的OpenSSL的接口，放上借用的库链接<a href=\"https://github.com/dgkang/rsa，最终测试结果是与Go库中的结果是一样的。我这里用的库是https://github.com/wenzhenxi/gorsa，因为官方库并没有将RSA私钥加密暴露出来，若需要使用的话就需要自己动手了。\" target=\"_blank\" rel=\"noopener\">https://github.com/dgkang/rsa，最终测试结果是与Go库中的结果是一样的。我这里用的库是https://github.com/wenzhenxi/gorsa，因为官方库并没有将RSA私钥加密暴露出来，若需要使用的话就需要自己动手了。</a></p>\n<p>第四步，我单方面的证明了Go库没有问题，此时怀疑的方向就只能是STM32官方库出了问题，哪里出了问题呢。偶然地，在使用<a href=\"https://github.com/dgkang/rsa库时，OpenSSL上报错信息是：error:0407006A:rsa\" target=\"_blank\" rel=\"noopener\">https://github.com/dgkang/rsa库时，OpenSSL上报错信息是：error:0407006A:rsa</a> routines:RSA_padding_check_PKCS1_type_1:block type is not 01。这个报错信息很关键，STM32库上说的是PKCS1 padding方式，那现在OpenSSL又报出了type方式不同，那只能说明这是有点问题。使用了库的nopadding方式，可以解密出来的数据都打印出来（PKCS1会直接返回数据，填充的信息会直接过滤掉）。</p>\n<p><img src=\"clip_image001.png\" alt=\"img\"></p>\n<p>在调试时，这些数据也是一头雾水的，实际打印的信息是下面的，我实际想要的是后面的数字，这个byte数组和string乱码看的也是脑袋大，为了搞清楚这个，需要了解加密填充信息。</p>\n<p><img src=\"clip_image002.png\" alt=\"img\"></p>\n<p>以下介绍填充方式的知识皆参考自：</p>\n<p>RSA_PKCS1_PADDING</p>\n<p>来自 &lt;<a href=\"https://www.douban.com/note/338531480/\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/note/338531480/</a>&gt; </p>\n<p>padding的三种方式：</p>\n<p>RSA加密常用的填充方式有下面3种：</p>\n<p>1.RSA_PKCS1_PADDING 填充模式，最常用的模式</p>\n<p>要求:</p>\n<p>输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11</p>\n<p>如果输入的明文过长，必须切割，然后填充</p>\n<p>输出：和modulus一样长</p>\n<p>2.RSA_PKCS1_OAEP_PADDING</p>\n<p>输入：RSA_size(rsa) – 41</p>\n<p>输出：和modulus一样长</p>\n<p>3.RSA_NO_PADDING　　不填充</p>\n<p>输入：可以和RSA钥模长一样长（因为不填充，必须要填入模长），如果输入的明文过长，必须切割，然后填充</p>\n<p>输出：和modulus一样长</p>\n<p>其中PKCS1需要遵守的填充规则是</p>\n<p><img src=\"clip_image003.png\" alt=\"img\"></p>\n<p>可以看到数据组成方式是有着固定的规则的。</p>\n<p>那再看看我们从STM32解密出来的数据，可以看到这个数据有点问题，明明是私钥加的密，开头确实0 2，大概率这里有问题。</p>\n<p><img src=\"clip_image001-1534941259919.png\" alt=\"img\"></p>\n<p>于是我在我的私钥加密中，将这位修改成2，将数据发给STM32,32那边随即便将数据返回出来了。</p>\n<p>还有一个问题，那就是为什么PKCS标准需要留11个字节呢。</p>\n<p><img src=\"clip_image004.png\" alt=\"img\"></p>\n<p>这11个字长那么大概率就是为了增加秘钥安全性所预留的随机数了。</p>\n<p>至此，算是终于将问题找到，并找到解决的办法了，解决问题大概是经历了那几个步骤，中间夹杂着各种尝试，当然写出来的却是每一步走得都很正确，中间与人沟通的成本不低，沟通愉快的时候解决问题的方法就会非常的多。</p>\n","categories":[{"name":"项目","slug":"项目","permalink":"chunlife.top/categories/项目/"}],"tags":[{"name":"Go","slug":"Go","permalink":"chunlife.top/tags/Go/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"chunlife.top/tags/OpenSSL/"},{"name":"RSA加密解密","slug":"RSA加密解密","permalink":"chunlife.top/tags/RSA加密解密/"}]},{"title":"搭建博客——使用Hexo","date":"2018-07-22T15:32:05.000Z","path":"2018/07/22/搭建博客——使用Hexo/","content":"<h3 id=\"搭建博客\"><a href=\"#搭建博客\" class=\"headerlink\" title=\"搭建博客\"></a>搭建博客</h3><p>使用GitHub和Hexo搭建博客其实是非常顺畅的，毕竟工具到现在都已经经历很多版本的迭代了，已经很傻瓜式了。</p>\n<p>推荐搭建的教程：</p>\n<a id=\"more\"></a>\n<p>关于Hexo6.0搭建个人博客(github+Google-收录篇)，博主还有教我们怎么收录百度的博客，道理是一样的。</p>\n<p><a href=\"https://www.imooc.com/article/31085\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/article/31085</a></p>\n<p>这里提一点绑定的事，附上我的DNS解析：</p>\n<p><img src=\"1532523945344.png\" alt=\"DNS解析\"></p>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>这里主要是提一下我遇到的一个插入图片的问题，这里我使用的Hexo主题是yilia。 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<p>yilia需要会提示我们安装一个插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-generator-json-content --save</span><br></pre></td></tr></table></figure>\n<p>但很奇怪的是，我在安装完这个插件后，我的hexo-asset-image——图片链接转换插件就不见了，导致我莫名其妙的图片无法显示了，Google多次无果，重新部署时才发现这个问题（没有细心去找），实在是没想到会出现这个问题，所以在装完这个插件后，又手动将hexo-asset-image插件给安装了回来，之后网页和本地都没有显示问题了，撒花。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n<p>当然，我还看到有人遇到图片显示不出来的其他问题，如果和你的问题对上了，可以看看：</p>\n<p>hexo中完美插入本地图片</p>\n<p><a href=\"http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/\" target=\"_blank\" rel=\"noopener\">http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</a></p>\n<h3 id=\"2018年7月25日20-54-20\"><a href=\"#2018年7月25日20-54-20\" class=\"headerlink\" title=\"2018年7月25日20:54:20\"></a>2018年7月25日20:54:20</h3><p>在这个时候又添加上这段话，是因为博客无法显示图片了，hexo-asset-image好像无法替我正常转换图片路径了，对JS的源码无法分析，只能提供一个issue，同时在网上查找答案，在白天的时候找个一个方法，将其截图，准备晚上试试，发现这个方法好像确实好使。</p>\n<p><strong>注意</strong>：使用该方法则不能保留hexo-asset-image，直接去module目录删除即可。</p>\n<p><img src=\"1532523531403.png\" alt=\"Hexo插入图片方法\"></p>\n<p>原链接没有保存，故无法放出链接了，需要的可自行Google。</p>\n<p>修改后可配合Typora使用，其在“编辑”——“图片工具”中，可设置图片根目录，将其定位到图片所在即可。</p>\n","categories":[{"name":"环境","slug":"环境","permalink":"chunlife.top/categories/环境/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"chunlife.top/tags/搭建博客/"}]}]